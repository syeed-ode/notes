This information was gather from freading Java Security 2nd Edition by O'Reilly.  It is a listing of notes and information.  Not sure how immediately helpful, but as I went through this material it helped me out greatly in defining terms, relating different components and keeping track of relationships between objects.
*
*
*
*
****Chapter 7 - Introduction to Cryptology****
author authentication - identity of the site
data authentication - assure the class was not modified in transit over the network
*
*
*
*
****Chapter 8 - Security Providers****
input data + key -> engine -> encrypted output data; // this is a '''cryptographic engine''' for encryption
	where,
		input data = (April is the cruelest month)
		encrypted output data = (Ncevy vf gur pehryg zbagu)
		engine = (Some algorithm (DSA/MD5) which perform encryption operation)

there are two standard cryptographic engines - 
		1) a message digest engine and 
		2) a digital signature engine.
The first engines we'll look at generate cryptographic keys. All together there are three types of keys −− secret, public, and private. Public and private are a key pair.


engine - MD & DigSig
engine - operation (cryptographic algorithm itself (operation))
       - message digest may be implemented by a particular algorithm, such as MD5 or SHA
       - abstract class
       - (i.e. Engine.class(es)) these classes come with the Java virtual machine as part of the core API
algorithm - an implementation of an engine (MD5 or SHA, for message digest); i.e. particular implementations of the cryptographic operation
          - defines how a particular operation should be executed
          -  (i.e. Algorithm.class(es)) there is a set of classes that implement particular algorithms for particular engines; 
             single algorithm class provides a particular algorithm for a particular engine.
          - 

security providers   
	** The security providers rely on cooperation between themselves and the rest of the Java security package in
	order to fulfill their purpose. The details of this cooperation are handled for us −− when we use the
	MessageDigest class to generate a digest, for example, it's the responsibility of the MessageDigest
	class to ask the Security class which particular class to use to generate the digest. The Security class in
	turn asks each of the providers whether or not they can supply the desired digest.

security providers   
	- the security provider is transparently useful to the programmer and to the end user. 
	     a system administrator, or a developer can configure the security provider; 
	     this is a result of the security provider being based on a set of provider classes.
	-   the glue that manages the mapping between:
	           - engines used by the rest of the security package (such as a message digest)
	           - the specific algorithms that are valid for those engines (such as an SHA digest for MD5 engine)
	           - the availability of the specific implementations of that algorithm/engine pair to any particular Java virtual machine
	           - allows an easy mechanism where the specific algorithms and their implementations can be easily changed or substituted


Provider.class - A provider knows how to map particular algorithms to the actual class that implements the operation
Security.class - The Security class maintains a list of the provider classes and consults each in turn to see which operations it supports
                 ******  These two classes together make up the idea of a security provider   ******
*
*
*
*
****Chapter 9 - Key's and Certificates****
Listing of providers, their services, the algorithms associated with these services, and the provider keys.  This information is useful when determining which algorthim you would like your key to be generated with.
This was moved to ../providerList
--
*
*
*
*
****Chapter 10 - Key Management****
Common Keytool Commands and options:

certificate		Verifies the public key is from who it says it's from.  Certificate Authority signs the cert. Contains: 1) signed by verifier, 2) public key of person (to whome the cert has been issued), 3) DN of person
key entry		Entry in keystore may be an asymmetric key pair, in which case it may store a chain of certificates: the first certificate always contains the public key of the entity. Or it may hold a secret key. 
cert entry		Entry in keystore only a public key certificate.
keypass 		Password for the entire keystore
storepass		Password for the entry of the particular private key (should be different from keypass)
distinguished Name	Full name of the keystore entry (could be a cert-store entry or key entry)
JKS			Key store engine. JKS stores on private keys. 
JCEKS			Key store engine. JCEKS stores secret keys (obviously) and private keys. 
PKCS12			Key store engine. PCKS can be read and export keys -- but cannot write!! Algorithm does not supply a fully−functional keystore
Certificate Signing
Request (CSR)		Need to obtain a certificate from CA for a specific alias.  It contains: 1) DN, 2) public key and 3) ***SIGNED WITH PRIVATE KEY***


To go through the process of getting a valid cert
1) Generate a private key
2) Use key alias to generate a certificate signing request (CSR)
	-- This is where I had problems.  When I went to the get a self-signed cert, the CA didn't like my CSR. Passing through state length requirements and comman name issues only to end up at a wrong formatting issue.  I skiped using the keytool to generate my private key and went to openssl.
				  (third attempt)#: keytool -genkey -alias syeedsthirdkey -keyalg RSA
				    (genrate csr)#: keytool -certreq -alias syeedsthirdkey  -file sboCSR.cer ## wrong format reported by CA (www.thawte.com, pronounced thought)
	   I was able to use openssl to generate a private key and signing request (CSR).  But that private key wasn't in my keystore. 
        			  (priv key &CSR)#: openssl req -new -newkey rsa:2048 -nodes -keyout syeedsfourth.key -out sboCSR.csr
	   Now I'm attempting to get that private key (and signed certificate) in my keystore. To do that take the following steps:
	   	a) convert the certificate and PCKS into a PCKS12 file (used for storing private keys with their certs)
			  i) validate the certificate
			                         #: keytool -list -v
						 [CSR, PRIVAKE KEY, and CERT ALL MATCH]
		      (validate csr with openssl)#: openssl pkey -in privateKey.key -pubout -outform pem | sha256sum
		      (validate csr with openssl)#: openssl x509 -in certificate.crt -pubkey -noout -outform pem | sha256sum
		      (validate csr with openssl)#: openssl req -in CSR.csr -pubkey -noout -outform pem | sha256sum
						 [CERTIFICATE FOR PRIVATE KEY]
			  (validate with openssl)#: openssl x509 -in  certificate.pem
	           (validate with openssl output)#: openssl x509 -text -noout -in certificate.pem
		            (validate public key)#: openssl x509 -pubkey -noout -in certificate.pem | shasum5.16
			 ii) validte the private key is ok (-text option can be removed)
						 [IMPORT CERT DIRECTLY]
	      (import cert directly with keytool)#: keytool -importcert -file applesCert.cer -alias "applescert"
						 [PRIVATE KEY]
			  (validate with openssl)#: openssl rsa -check -text -noout -modulus -in key.pem
			      (verify public key)#: openssl rsa -pubout -in key.pem 2>&1| grep -v "writing RSA key" | shasum5.18
			iii) (finally) import both the private key and certificate into the pkcs12 file
						 [PKCS12 KEY STORE]
			   (generate pkcs12 file)#: openssl pkcs12 -inkey key.pem -in certificate.pem -export -out pkcs12Cert.p12
		 (validate new cert with openssl)#: openssl pkcs12 -in pkcs12Cert.p12 -noout -info
		b) you can use the -changealias/-keyclone/-keypasswd/-storepasswd options with sub options as demonstrated below
		c) import the PCKS12 file into the keystore
	  		      (verify public key)#: keytool -importkeystore -srckeystore pkcs12Cert.p12 -srcstoretype PKCS12
	  (change the alias name inside keystore)#: keytool -changealias -alias 1 -destalias syeedsselfsigned
3) New method to generate Certificate Signing Request (CSR)
	-- I'm assuming the first CSR was due to an invalid key not being strong enough
	-- So, this time I used RSA with strength of 2048.  (Basically, the command from up top)
	-- I requested the keytool to issue me a CSR from the imported PKCS12 file
				  (generate csr)#: keytool -certreq -alias syeedsselfsigned  -file selfsignedCsr.cer
	-- I validated the CSR with openssl req
						 [CSR - Certificate Signing Request]
			     (validated teh csr)#: openssl req -text -in selfsignedCsr.cer
	-- Now I'm submitting the CSR to thawte for a CA signed cert...they won't let me do it for free...


The Key Management API
Princle.class 		- the notion of to whom the key belongs

*
*
*
*
****Chapter 14 - SSL and HTTPS****
keystores 		- Provides credentials (usually for the server to give to the client) 
			- should only hold one key entry (server's private key with certificate)
trustore		- Verifies (server) credentials (usually for the client) 
			- receives servers ca with a host of certificate chains

To create a client truststore 1) export a private key entry into a certificate, 2) impor the certificate into a trust store
						 [CERTIFICATE FROM KEYSTORE]
	    (expoert key entry cert with keytool)#: keytool -export -alias syeedsthirdkey -file test.cer
					    [TRUSTED CERTIFICATE TO TRUSTSTORE]
       (import certificate entry into truststore)#: keytool -import -alias test -keystore $HOME/.truststore -file test.cer

I ran into two problems. Once was on the server.  I ran into the UnreoverableKeyError.  I had to manually remove all of the entries from my keystore.
The second issue was on the client side.  I couldn't specify the truststore location via the IntelliJ IDE vm arguments.  The app continued to complain.  So, I moved the $JAVA_HOME/jre/lib/security/cacerts to a backup and replaced it with my .truststore file. That got everything working.

So, I added two client applications.  One to explicitly verify the truststore alias matches the server alias (SecurityExecutionMain.executeSSLClientVerifier). (It does this by grabbing the SSLSession which has the certificate chain.)  The other takes the verification for granted and grabs a client socket (socketFactory.createSocket) and communicates outright. They client threw this code:
javax.net.ssl.SSLException: Connection has been shutdown: javax.net.ssl.SSLException: Received fatal alert: internal_error
	at sun.security.ssl.SSLSocketImpl.checkEOF(SSLSocketImpl.java:1541)
	at sun.security.ssl.AppInputStream.read(AppInputStream.java:95)
	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)
	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)
	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)
	at java.io.InputStreamReader.read(InputStreamReader.java:184)
	at java.io.BufferedReader.fill(BufferedReader.java:161)
	at java.io.BufferedReader.readLine(BufferedReader.java:324)
	at java.io.BufferedReader.readLine(BufferedReader.java:389)
	at com.syeedode.security.client.SSLClient.executeSSLClient(SSLClient.java:35)
	at com.syeedode.security.main.SecurityExecutionMain.main(SecurityExecutionMain.java:16)
Caused by: javax.net.ssl.SSLException: Received fatal alert: internal_error
	at sun.security.ssl.Alerts.getSSLException(Alerts.java:208)
	at sun.security.ssl.Alerts.getSSLException(Alerts.java:154)
	at sun.security.ssl.SSLSocketImpl.recvAlert(SSLSocketImpl.java:2023)
	at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1125)
	at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1375)
	at sun.security.ssl.SSLSocketImpl.writeRecord(SSLSocketImpl.java:747)
	at sun.security.ssl.AppOutputStream.write(AppOutputStream.java:123)
	at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)
	at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)
	at sun.nio.cs.StreamEncoder.implFlush(StreamEncoder.java:295)
	at sun.nio.cs.StreamEncoder.flush(StreamEncoder.java:141)
	at java.io.OutputStreamWriter.flush(OutputStreamWriter.java:229)
	at java.io.BufferedWriter.flush(BufferedWriter.java:254)
	at java.io.PrintWriter.flush(PrintWriter.java:320)
	at com.syeedode.security.client.SSLClient.executeSSLClient(SSLClient.java:34)
	... 1 more

I received this execption on the server side code that uses my personal KeyManager (SSLWithKeyManagerService.executeSSLServerWithKeyManager).  The server threw this error:
Couldn't find the correct algorithm for the alias
javax.net.ssl.SSLException: java.lang.NullPointerException
	at sun.security.ssl.Alerts.getSSLException(Alerts.java:208)
	at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1949)
	at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1906)
	at sun.security.ssl.SSLSocketImpl.handleException(SSLSocketImpl.java:1889)
	at sun.security.ssl.SSLSocketImpl.handleException(SSLSocketImpl.java:1815)
	at sun.security.ssl.AppInputStream.read(AppInputStream.java:116)
	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)
	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)
	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)
	at java.io.InputStreamReader.read(InputStreamReader.java:184)
	at java.io.BufferedReader.fill(BufferedReader.java:161)
	at java.io.BufferedReader.readLine(BufferedReader.java:324)
	at java.io.BufferedReader.readLine(BufferedReader.java:389)
	at com.syeedode.security.ssl.SSLServer.run(SSLServer.java:41)
Caused by: java.lang.NullPointerException
	at java.util.Arrays.stream(Arrays.java:5004)
	at com.syeedode.security.keys.keymanager.SSLKeyManager.chooseClientAlias(SSLKeyManager.java:61)
	at com.syeedode.security.keys.keymanager.SSLKeyManager.chooseServerAlias(SSLKeyManager.java:78)
	at sun.security.ssl.AbstractKeyManagerWrapper.chooseServerAlias(SSLContextImpl.java:1230)
	at sun.security.ssl.ServerHandshaker.setupPrivateKeyAndChain(ServerHandshaker.java:1451)
	at sun.security.ssl.ServerHandshaker.trySetCipherSuite(ServerHandshaker.java:1210)
	at sun.security.ssl.ServerHandshaker.chooseCipherSuite(ServerHandshaker.java:1026)
	at sun.security.ssl.ServerHandshaker.clientHello(ServerHandshaker.java:741)
	at sun.security.ssl.ServerHandshaker.processMessage(ServerHandshaker.java:224)
	at sun.security.ssl.Handshaker.processLoop(Handshaker.java:1026)
	at sun.security.ssl.Handshaker.process_record(Handshaker.java:961)
	at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1062)
	at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1375)
	at sun.security.ssl.SSLSocketImpl.readDataRecord(SSLSocketImpl.java:928)
	at sun.security.ssl.AppInputStream.read(AppInputStream.java:105)
	... 8 more
It received an "EC" as the algorithm type.  I have no idea why the client is sending that. Or where it got it from.  Without a Google search, I decided to move on. I spent two days or maybe 3 in this section lone.
