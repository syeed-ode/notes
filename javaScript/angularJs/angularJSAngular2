This information was gather from reading Learning Angular JS: A Guide to AngularJS Development by Ken Williamson. 
*
*
*
*
****    Chapter 1 - Introduction to AngularJS    ****
Single-page applications (SPAs) are applications that have one entry point HTML page; all the application content 
	is dynamically added to and removed from that one page.
The tag <div ngview></div> is where all dynamic content is inserted into index.html.
			<!-- chapter1/index.html -->
			<!DOCTYPE html>
			<html lang="en" ng-app="helloWorldApp">
				<head>
					<title>AngularJS Hello World</title>

					<meta name="viewport" content="width=device-width, initial-scale=1.0">
					<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
					
					<script src="js/libs/angular.min.js"></script>
					<script src="js/libs/angular-route.min.js"></script>
					<script src="js/libs/angular-resource.min.js"></script>
					<script src="js/libs/angular-cookies.min.js"></script>
					<script src="js/app.js"></script>
					<script src="js/controllers.js"></script>
					<script src="js/services.js"></script>
				</head>
				<body>
					<div ng-view></div>
				</body>
			</html>
As the user clicks on links in the application, existing content attached to the tag is removed and new dynamic 
	content is then attached to the same tag. Rather than the user waiting for a new page to load, new content 
	is dynamically displayed in a fraction of the time that it would take to load a new HTML web page.
Bootstrapping AngularJS is the process of loading AngularJS when an application first starts. 'app.js' is where the 
	AngularJS application helloWorldApp is defined as an AngularJS module, and this is the entry point into the 
	application. 
			/* chapter1/app.js excerpt */
			'use strict';
			/* App Module */
			var helloWorldApp = angular.module('helloWorldApp', [
				'ngRoute',
				'helloWorldControllers'
			]);
Dependency injection (DI) is a design pattern where dependencies are defined in an application as part of the 
	configuration. Two dependencies (a route and controller) are defined as needed by the helloWorldApp 
	application at startup. The dependencies are defined in an array in the module definition.
Dependency injection also helps to make an application more testable. That is one of the main advantages of 
	using AngularJS to build JavaScript applications. AngularJS applications are much easier to test than 
	applications written with most JavaScript frameworks.
AngularJS routes are defined through the '$routeProvider' API. Two routes are defined — the first is '/' and 
	the second is '/show'. The two defined routes map directly to URLs defined in the application. 
			/* chapter1/app.js complete file */
			'use strict';

			/* App Module */
			var helloWorldApp = angular.module('helloWorldApp', [
				'ngRoute',
				'helloWorldControllers'
			]);
			helloWorldApp.config(['$routeProvider', '$locationProvider',
				function($routeProvider, $locationProvider) {
					$routeProvider.
						when('/', {
							templateUrl: 'partials/main.html',
							controller: 'MainCtrl'
						}).when('/show', {
							templateUrl: 'partials/show.html',
							controller: 'ShowCtrl'
						});
			$locationProvider.html5Mode(false).hashPrefix('!');
			}]);
The last line in app.js '($locationProvider.html5Mode(false).hashPrefix('!');)' uses the locationProvider 
	service. This line of code turns off the HTML5 mode and turns on the hashbang mode of AngularJS. If 
	you were to turn on HTML5 mode instead by passing true, the application would use the HTML5 History 
	API. HTML5 mode also gives the application pretty URLs like /someAppName/blogPost/5 instead of the 
	standard AngularJS URLs like /someAppName/#!/blogPost/5 that use the #!, known as the hashbang.
HTML5 mode does require configuration changes on the web server in most cases. HTML5 mode also handles URL by 
	using the HTML History API for navigation. 
Hashbang mode is used to support conventional search engines that don’t have the ability to execute JavaScript on 
	Ajax sites like those built with AngularJS. Conventional search engines expect the server to have HTML 
	snapshots, which are merely copies of the HTML rendered version of the website or application.
Fortunately, modern search engines have the ability to execute JavaScript. Hashbang mode also allows AngularJS 
	applications to store Ajax requested pages in the browser’s history. That process often simplifies 
	browser bookmarks.
AngularJS Templates (Templates are the views):
	Templates are code sections that contain HTML code that are bound to the <div ng-view></div> tag shown 
		in the index.html file. In the app.js file, you can see that different 'templateUrl' values 
		are defined for each route. AngularJS’s built-in template language can display dynamic data in 
		templates.
	As the user clicks on the different links, the value assigned to <div ng-view> is replaced with the 
		content of the associated template files. The value of the controller defined for each route 
		references the controller component (of the MVC pattern) that is defined for each particular 
		route.
	Unlike most JavaScript client-side frameworks, AngularJS provides the model, view, and controller 
		components for use in all applications.
	Many JavaScript client-side frameworks require you to actually define the view classes in JavaScript. 
		Such is not the case with AngularJS. AngularJS pulls in all the templates defined for an 
		application and builds the views in the document object model (DOM) for you. Therefore, the 
		only work you need to do to build the views is to create the templates.
AngularJS Models (MVC) ($scope is the model):
	Many JavaScript client-side frameworks also require you to create JavaScript model classes. AngularJS 
		has a $scope object that is used to store the application model. Scopes are attached to the DOM. 
		The way to access the model is by using data properties assigned to the $scope object.
AngularJS Controllers (MVC):
	AngularJS controllers are the tape that holds the models and views together. The controller is where you 
		should place all business logic specific to a particular view when it’s not possible to place the 
		logic inside a REST service. Business logic should almost always be placed in backend REST 
		services whenever possible; this helps to simplify AngularJS applications.
	When business logic placed inside an application is used by multiple controllers, it should be placed in 
		AngularJS non-REST services instead. Those services can then be injected into any controller that 
		needs access to the logic.
	The following code shows the contents of the controllers.js file. At the start of the file we define the 
		helloWorldController module. We then define two new controllers, 'MainCtrl' and 'ShowCtrl', and 
		attach them to the helloWorldController module. Business logic specific to the 'MainCtrl' 
		controller is defined inside that controller. Likewise, business logic specific to the 
		'ShowCtrl' controller is defined inside the ShowCtrl controller. The $scope that is injected 
		into each controller is specific to that controller and not visible to other controllers.
			/* chapter1/controllers.js */
			'use strict';
			/* Controllers */
			var helloWorldControllers =
			angular.module('helloWorldControllers', []);

			helloWorldControllers.controller('MainCtrl', ['$scope',
				function MainCtrl($scope) {
					$scope.message = "Hello World";
			}]);

			helloWorldControllers.controller('ShowCtrl', ['$scope',
				function ShowCtrl($scope) {
					$scope.message = "Show The World";
			}]);
As you can see, we are now using the model to populate the messages that get displayed in the templates. The 
	following code shows the modified templates that use the newly created model values. The line 
	$scope.message = "Hello World" in the 'MainCtrl' controller is used to create a property named message 
	that is added to the scope (which holds the model attributes).
			<!-- chapter1/main.html -->
			<div>{{ message }}</div>
			<!-- chapter1/show.html -->
			<div>{{ message }}</div>
Using double curly braces is AngularJS’s way of displaying scope properties in the view. 
*************************************************************
*							    *
*							    *
*							    *
****    Chapter 2 - The IDE and AngularJS Projects    *******
Testing AngularJS Applications in the IDE
	To enable the chrome bar for debugging go to 'chrome://flags/#silent-debugger-extension-api'.

	There are two types of tests that are used for testing AngularJS applications. The first type of test is the unit test. The second type of test is end-to-end (E2E) testing. E2E testing helps to identify software defects by testing how components connect and interact together as a whole.

	NetBeans can easily work with both JsTestDriver and Karma for unit testing AngularJS applications. Protractor is the most popular test framework for E2E testing of AngularJS applications. NetBeans currently has no support for Protractor. 

	Both Karma and Protractor run on Node.js. Node.js is an open source cross-platform framework built on the Google V8 JavaScript engine. Installing Karma and Protractor is a relatively easy process that uses the Node.js package manager (npm) for the installation process.

	Node.js-based projects use a JSON file named package.json as the project configuration file. The following is a standard package.json file used in a NetBeans project. If you look at the dependencies section of the file, you will see that we actually define Karma as a dependency of the application. That is because Karma is usually installed locally at the project level for each individual project: 
			{"chapter": 2, "name": "package.json"},

			{
			    "name": "UlboraCmsMean",
			    "version": "2.0.0",
			    "description": "UlboraCms",
			    "keywords": [
			        "Ulbora CMS",
			        "Node.js",
			        "Ken",
			        "Williamson",
			        "micbutton.com"
			    ],
			    "author": {
			        "name": "Ken Williamson",
			        "email": "sales@drivensolutions.com",
			        "url": "http://www.drivensolutions.com/"
			    },
			    "homepage": "http://www.ulboracms.org",
			    "repository": {
			        "type": "git",
			        "url": "https://github.com/Ulbora/ulboracms"
			    },
			    "engines": {
			        "node": ">= 0.6.0",
			        "npm": ">= 1.0.0"
			    },
			    "dependencies": {
			        "express": "~3.4.4",
			        "mongoose": "*",
			        "atob": "*",
			        "btoa": "*",
			        "node-rest-client": "*",
			        "consolidate": "*",
			        "ejs": "*",
			        "handlebars": "*",
			        "nodemailer": "*",
			        "karma": "*"
			    },
			    "bundleDependencies": [],
			    "private": true,
			    "main": "./server.js",
			    "bugs": {
			        "url": "null"
			    }
			}
	A file similar to this one will be used later in the book when we build the MEAN stack blog application. NetBeans, using a Node.js plugin, can generate the package.json file for you. The generated file will need to be modified to include the specifics of your particular project.

	You can also use 'npm init' to generate the package.json file. After typing 'npm init' at the command prompt, you will be presented with a few questions. Your responses will then be used to create a default 'package.json' file.

	NetBeans has built-in support for JsTestRunner. The JsTestRunner configuration file can be generated and requires few changes to get unit testing running on your local environment. Unlike Karma, JsTestRunner is not based on Node.js.

JsTestRunner
	The following is a standard JsTestRunner configuration file created by NetBeans for an AngularJS project. Notice in the first line that the test server URL and port are specified:
			/* chapter2/jsTestDriver.conf */
			server: http://localhost:42442
			load:
			- test/lib/jasmine/jasmine.js
			- test/lib/jasmine-jstd-adapter/JasmineAdapter.js
			- public_html/js/libs/angular.min.js
			- public_html/js/libs/angular-mocks.js
			- public_html/js/libs/angular-cookies.min.js
			- public_html/js/libs/angular-resource.min.js
			- public_html/js/libs/angular-route.min.js
			- public_html/js/*.js
			- test/unit/*.js
			exclude:

The locations of the test library files are specified under load. We also specify the locations of each unit test script that should be run by JsTestDriver. Test filenames usually end with “Spec.” 
			/* chapter2/controllerSpec.js */
			/* Jasmine specs for controllers go here */

Karma Test Runner
	The Karma team recommends installing Karma locally at the project level. So, we will add Karma in the 'package.json' file of each of our projects, then use the following command to pull down and install Karma on a per-project basis:
				npm install
	When you run this command, 'npm' reads the 'package.json' file and installs the packages defined in the dependencies section of the file. After you run the command, Karma will be located under the node_modules folder within your project folder. Any other Node.js dependencies defined in the package.json file will also be located under the node_modules folder.

	Karma requires a configuration file named 'karma.conf.js' that specifies how it should run unit tests. 
				./node_modules/body-parser/node_modules/debug/karma.conf.js
				./node_modules/finalhandler/node_modules/debug/karma.conf.js
				./node_modules/follow-redirects/node_modules/debug/karma.conf.js
				./node_modules/fsevents/node_modules/debug/karma.conf.js
				./node_modules/karma/node_modules/debug/karma.conf.js
				./node_modules/mquery/node_modules/debug/karma.conf.js
	You can use NetBeans to generate the 'karma.conf.js' file. The following code shows a Karma configuration file generated by NetBeans. You can see there are sections of the file to specify the locations of library files, test scripts, and browser plugins:
				/* chapter2/karma.conf.js */
				/*
				* To change this license header, choose License Headers in
				* Project Properties.
				* To change this template file, choose Tools -> Templates
				* and open the template in the editor.
				*/
				module.exports = function (config) {
					config.set({
						basePath: '../',
						files: [
						],
						exclude: [
						],
						autoWatch: true,
						frameworks: [
						],
						browsers: [
						],
						plugins: [
						]
					});
				};
Protractor
	Protractor is a Node.js-based framework, just like Karma. Protractor is built on top of WebDriverJS. The Protractor team recommends installing Protractor globally on your system. To install Protractor on your development machine, issue the following command. Notice the -g flag in the command line — that tells npm to install Protractor globally for all projects and applications to use:
			[20171007-13:52:43 syeedode:~/angular_projects/angular-js-scratchwork/AngularJsProject master*] $ npm install -g protractor
					/usr/local/bin/protractor -> /usr/local/lib/node_modules/protractor/bin/protractor
					/usr/local/bin/webdriver-manager -> /usr/local/lib/node_modules/protractor/bin/webdriver-manager
			+ protractor@5.1.2
			added 126 packages in 7.673s
	Since Protractor is built on WebDriverJS, we must also configure WebDriverJS for our test environment. Run this command to update WebDriverJS with all the latest binaries:
			[20171007-13:53:03 syeedode:~/angular_projects/angular-js-scratchwork/AngularJsProject master*] $ webdriver-manager update
				[14:25:26] I/file_manager - creating folder /usr/local/lib/node_modules/protractor/node_modules/webdriver-manager/selenium
				[14:25:27] I/update - chromedriver: unzipping chromedriver_2.33.zip
				[14:25:27] I/update - chromedriver: setting permissions to 0755 for /usr/local/lib/node_modules/protractor/node_modules/webdriver-manager/selenium/chromedriver_2.33
				[14:25:27] I/update - geckodriver: unzipping geckodriver-v0.19.0.tar.gz
				[14:25:27] I/update - geckodriver: setting permissions to 0755 for /usr/local/lib/node_modules/protractor/node_modules/webdriver-manager/selenium/geckodriver-v0.19.0
	Once that command executes successfully, run the following command to start the Selenium Server that WebDriverJS uses to run Protractor test scripts:
				webdriver-manager start
	Protractor needs a configuration file that tells it how to run test scripts. Here are the contents of the 'conf.js' file used to configure Protractor:
				/* chapter2/conf.js Protractor configuration file */
				exports.config = {
					seleniumAddress: 'http://localhost:4444/wd/hub',
					specs: ['blog-spec.js']
				};
	Once Protractor is installed and configured on your system, all that is left is to create the test scripts (test specifications) and run the scripts. Here’s a sample script for a Protractor test:
				/* chapter2/blog-spec.js */
				describe('MEAN Blog', function() {
					it('test the MEAN Blog', function() {
						browser.get('http://localhost:8080');
						
						element(by.model('blogList'))
							.sendKeys('this is a blog post');

						element(by.css('[value="add"]')).click();
						
						var blogList = element.all(by.repeater('blog in blogs'));
						
						expect(blogList.count()).toEqual(3);
						
						expect(blogList.get(2)
							.getText())
							.toEqual('this is a blog post');
					});
				});
To run Protractor, issue the following command. Once you run the command, the browser window should open and display the test results:
				protractor conf.js
*************************************************************
*							    *
*							    *
*							    *
****    Chapter 3 - MVC and AngularJS   *********************
There are two advantages for using angular: 1) Support for mobile devices and 2) quicker development time adn quicker testing time because of the use of JavaScript. The second benefit has an addtional benefit of faster CI time.

AngularJS presents a new and powerful way to develop web applications and websites — it has the power and functionality of conventional web frameworks, but with many advantages. AngularJS provides a way to build web apps and sites without the overhead normally associated with web frameworks.

Conventional web frameworks often tolerate server-side page scripting using PHP, Active Server Pages (ASP), and Java Server Pages (JSP). Conventional web frameworks tend to run slower and be sluggish on mobile devices. And mobile users have a much lower tolerance for system delays and slow page loads than desktop users.

The Old Way
	Web MVC frameworks such as Apache Struts, Ruby on Rails, CakePHP, Spring MVC, and the Zend Frameworkvdominated the web development framework space for more than 15 years. Web MVC frameworks reside entirely on the server. All functions such as database access, business logic, display logic, and UI activities happen on the server, using server memory and resources. Web MVC frameworks often use various page scripting techniques such as ASP, JSP, and PHP to control presentation logic, and in some cases business logic is also placed inside the pages.

	The application or website runs on the backend server, and only the web browser runs on the user’s hardware. Although the design is old technology, it is still in heavy use today.

	Although the design works well in many situations, it does have several flaws. One such design flaw is related to mobile applications and mobile websites. The application or site developer has very little control over the mobile device’s web browser.

	A user must find the site or application and enter its URL into the browser’s address bar in order to view the web page or to run the application. Mobile users, however, often find that process too time-consuming..

	A mobile developers need to build custom device applications and have those applications distributed via the various online stores. As the number of mobile devices in use increases, the demand for custom mobile applications will also increase. A user with a small smartphone should have the same user experience as a user with a 10-inch tablet..

	An application developer or architect attempting a mobile design has two choices to consider..

	Choice One
		The first option is to build a custom mobile application as a “wrapper” around the conventional site. This option has an Android application designed as a wrapper application. The Android application consists solely of an Android 'WebView' component that is configured to point to the web application URL. 

						Android Mobile Application
	---------------------------------------------------------------
	-						Native Android Code					  - 
	-	--------------------------------------------------------- -
	-	-					wrapper 							- -	w
	-	-	-------------------------------------------------	- -	e
	-	-	-												-	- -	b
	-	-	-			Android WebView			<----->		=	- -	a
	-	-	-												-	- -	p
	-	-	-------------------------------------------------	- -	p
	-	--------------------------------------------------------- -
	-															  -
	---------------------------------------------------------------
		The WebView component serves as a browser control inside the Android application. The developer can custom-configure the WebView component for the needs of the particular mobile application. All application operations still, however, run on the backend server (the web server), and the speed and responsiveness of the Android application are still highly dependent on that server and the quality of the user’s Internet connection.

		The following code shows a segment of an Android main Activity. A new Android 'WebView' object is first instantiated. JavaScript is then enabled for the new instance. Finally, the URL of the website is loaded into the new instance with the loadUrl method:
				/* chapter3 excerpt from an Android WebView shown loading a
				conventional website */
				WebView webview = new WebView(this);
				webview.getSettings().setJavaScriptEnabled(true);
				final Activity activity = this;
				webview.setWebViewClient(new WebViewClient() {
				webview.loadUrl("http://www.google.com");
		The WebView instance shown here is just a control for the device’s internal web browser. The Android device’s browser is completely dependent on the website for functionality. If the website that is linked to goes down or the network connection is lost, the user’s browser will hang and completely stop working

	Choice Two
		The second option would require the developer to write a native or HTML5 mobile application that called web services on the backend for business functions. 

		This approach would require adding REST web services to the existing web application to make use of existing business logic. Option two is, in effect, a complete rewrite of the application.

		Option two would, however, offer the best application design and would provide the best user experience.

		Fifteen years ago, when mobile devices were not in heavy use, that design was a common choice for application developers and architects.  Mobile device sales reached an all-time high in 2014, however, and most analysts predict that trend will only increase in the coming years.

		AngularJS is a solid foundation for building scalable applications that run well on desktops and a broad array of mobile devices, with few if any modifications needed for each platform.

A New and Better Way
	AngularJS is a JavaScript MVC framework that cuts development time for both web applications and mobile applications that run on multiple device platforms.

	AngularJS application that uses business logic that’s exposed through REST web services. Two popular frameworks used to build REST services are the Spring framework, written in Java, and ExpressJS for Node.js.

	In this design option, the entire AngularJS application runs on the user’s hardware, in the user’s web browser. That may be a desktop browser or the browser of a mobile device.

	With this design we shift the display logic from the server to the user’s hardware, resulting in a much better user experience. The application runs faster and is much more responsive — more like a thick-client or native application than a browser-based application. AngularJS applications harness the power of the user’s hardware.

	The final option is the same AngularJS application deployed as part of an Android application. JavaScript, CSS3, and HTML5 code is all the same regardless of where the application is deployed. Not only does the design produce a better user experience, but it also cuts development time significantly. And as with the web browser design option, the application runs entirely on the user’s hardware, shifting the load from the server to the user’s device.

Testing Considerations
	The ability to effectively and easily test AngularJS applications is one of the strongest motivators for using the framework. Not only are AngularJS applications faster to write, but they are also much faster and easier to test than conventional web framework–based applications. Here is why.

	Test scripts for AngularJS, known as test specifications, are always written in JavaScript.  One more thing: JavaScript tests run faster than tests written for conventional web frameworks. That is very important when a continuous integration system is used.

	The two most popular test frameworks used for client-side JavaScript and AngularJS, Karma and Protractor, run on the Node.js framework. Applications and test scripts that run on Node.js run extremely fast.  JavaScript testing is faster in a CI environment like Travis CI and Jenkins.

Responsive Design Considerations
	Another consideration when you are comparing traditional web frameworks to AngularJS
is how well responsive design is accomplished. A strong responsive design looks good
both on a desktop and on all mobile devices that use the software
	
	Take, for example, CSS3 with a server-side application written with CakePHP, a web MVC framework. An application styled with this code would look fine on a desktop, and maybe a tablet. There would be major styling issues with a small mobile device, however. A mobile wrapper application like the one I mentioned earlier that wrapped a website that used this code would be at a great disadvantage. You could never make the application look good on a small phone.
	
	A mobile application built with AngularJS has media query lines like '@media screen' and '(min-width: 1200px)'' that wrap parts of the CSS3. Media queries let developers style AngularJS applications to specific screen sizes

	If the web application written in CakePHP had been written with AngularJS, it would have been a simple task to convert the AngularJS application into a mobile application. The development team could then have fixed the CSS3 issues and been done. The application written with CakePHP had to be completely rewritten, however.
*************************************************************
*							    *
*							    *
*							    *
****    Chapter 4 - AngularJS Controllers      **************
Controllers
really have two primary responsibilities in an application. First, controllers should be used to initialize the model scope properties. These properties can be, then passed to the view (templates/parials).  The second primary use for controllers is adding behavior to the '$scope' object. 

AngularJS controllers are at the center of AngularJS applications and are probably the most important component to understand. AngularJS clearly defines controllers, and controllers are at the center of AngularJS applications. Almost everything that happens in an AngularJS application passes through a controller at some point.

Dependency injection is used to add the needed dependencies, as shown in the following example file, which illustrates how to create a new controller:
		/* chapter4/controllers.js - a new controller */
		var addonsControllers = angular.module('addonsControllers', []);

		addonsControllers.controller('AddonsCtrl',
			[	'$scope', 
				'checkCreds', 
				'$location', 
				'AddonsList', 
				'$http', 
				'getToken',
				function AddonsCtrl($scope, checkCreds, $location, AddonsList, $http, getToken) {
					if (checkCreds() !== true) {
						$location.path('/loginForm');
					}

					$http.defaults.headers.common['Authorization'] = 'Basic ' + getToken();
					
					AddonsList.getList({},
						function success(response) {
							console.log("Success:" +
							JSON.stringify(response));
							$scope.addonsList = response;
						},
						function error(errorResponse) {
							console.log("Error:" +
							JSON.stringify(errorResponse));
						}
					);

					$scope.addonsActiveClass = "active";
		}]);

In this code, we first create a new module named addonsController by making a call to the module method of angular. 
			var helloWorldControllers =  angular.module('helloWorldControllers', []);

On the second line, we create a new controller named AddonsCtrl by calling the controller method of the addonsControllers module. 
			addonsControllers.controller('AddonsCtrl',

Doing that attaches the new controller to that module. All controllers created in the controllers.js file will be added to the addonsControllers module.
			addonsControllers.controller('<controllerCreated>',

Also notice the line console.log("Success:" + JSON.stringify(response)). Most modern browsers have accompanying developer tools that give developers easy access to the JavaScript console. This line uses the JSON.stringify method to log the JSON that’s returned from the web service to the JavaScript console. Developers can easily use the JavaScript console to troubleshoot REST service issues by viewing the JSON logged in the success callback function, or in the error callback function if a service call fails.

The following code is an excerpt of the previous file. It shows how we use dependency injection to add dependencies to the new controller. This code shows $scope, checkCreds, $location, AddonsList, $http, and getTokens as dependencies for the new controller
		/* chapter4/controllers.js excerpt */
		/* using dependency injection */
		['$scope', 'checkCreds', '$location', 'AddonsList', '$http', 'getToken',
			function AddonsCtrl($scope, checkCreds, $location, AddonsList,, $http, getToken) {
		}

Initializing the Model ('$scope') with Controllers
	AngularJS controllers have two primary duties in an application. First, controllers should be used to initialize the model scope properties. When a controller is created and attached to the DOM, a child scope is created. The child scope holds a model used specifically for the controller to which it is attached. You can access the child scope by using the $scope object.

	Model properties can be added to the scope, and once added they are available inside the view templates. The controller code shown here illustrates how to add two properties to the scope. After adding the customer name and customer number to the scope, both are available to the view and can be accessed with double curly braces:
				/* chapter4/controllers.js excerpt */
				helloWorldControllers.controller('CustomerCtrl', ['$scope',
					function CustomerCtrl($scope) {
						$scope.customerName = "Bob's Burgers";
						$scope.customerNumber = "44522";
				}]);
		
				<!-- chapter4/partials/customer.html -->
				<div><b>Customer Name:</b> {{customerName}}</div>
				<div><b>Customer Number:</b> {{customerNumber}}</div>

Adding Behavior with Controllers
	The second primary use for controllers is adding behavior to the $scope object. We add behavior by adding methods to the scope, as shown in the following controller code. . Here, we attach a changeCustomer method to $scope so that it can be invoked from inside the view. By doing this, we are adding behavior that allows us to change the customer name and customer number:
			$scope.changeCustomer = function () {
			    $scope.customerName = $scope.cName;
			    $scope.customerNumber = $scope.cNumber;
			};

	The following code shows the customer.html file and the changes needed in the view to make use of the new behavior that was just added. We add two new properties to the model by using ng-model="cName" and ng-model="cNumber". We use ngclick="changeCustomer();" to invoke the new changeCustomer method that is attached to the scope:
				<form>
				    <div>
				        <input type="text" ng-model="cName" required/>
				    </div>
				    
				    <div>
				        <input type="number" ng-model="cNumber" required/>
				    </div>
				    
				    <div>
				        <button ng-click="changeCustomer();">Change Customer</button>
				    </div>
				</form>
	Once the changeCustomer method is invoked, the new properties are attached to $scope and available to the controller. As you can see, we simply assign the two new properties bound to the model back to the original two properties, customerName and customerNumber, inside the changeCustomer method. Both ng-model and ng-click are AngularJS directives.

Controller Business Logic
	Controllers are used as just demonstrated to add business logic to an application. Business logic added in the controller, however, should be specific to the view associated with that one controller and used to support some display logic functionality of that one view. Any business logic that can be pushed off the client-side application should be implemented as a REST service and not actually inside the AngularJS application.

	There is one caveat to this concept, however: REST services must have a response time of two (2) seconds or less. Long-running services will only cause delays in the UI and make for a bad user experience. 

	Business logic that can’t be placed in REST services but needs to be available to multiple controllers should not be placed in the controller but should instead be placed in AngularJS non-REST services. Business logic that is placed in the controller should be simple logic that relates only to the controller in which it is defined.

Presentation Logic and Formatting Data
	Presentation logic should not be placed inside the controller but instead should be placed in the view. AngularJS has features especially designed for formatting data, and that’s where data formatting should take place.

	As you can see, we use standard HTML for the form with nothing really special except the directives. The directive ng-submit binds the method named submit, defined in the AddCustomerCtrl controller, to the form for form submission. The ng-model directive binds the two input elements to scope properties.
					<form ng-submit="submit()" ng-controller="AddCustomerCtrl">					    
					    <div>
					        <input type="text" ng-model="cName" required/>
					    </div>
					    <div>
					        <input type="text" ng-model="cCity" required/>
					    </div>
					    <div>
					        <button type="submit">Add Customer</button>
					    </div>
					</form>

	Two or more controllers can be applied to the same element, and we can use controller as to identify each individual controller. The following code shows how controller as is used. You can see that addCust identifies the AddCustomerCtrl controller. We use addCust to access the properties and methods of the controller, as shown:
				<!-- chapter4/partials/newCustomer.html (with controller as) -->
				<form ng-submit="addCust.submit()" ng-controller="AddCustomerCtrl as addCust">
					<div>
						<input type="text" ng-model="addCust.cName" required/>
					</div>
					<div>
						<input type="text" ng-model="addCust.cCity" required/>
					</div>
					<div>
						<button id="f1" type="submit" >Add Customer</button>
					</div>
				</form>


Using Submitted Form Data
	In the code segment below, you can see there are two parameters, customer and city, for the addedCustomer route. The values are passed as arguments to a new controller, AddedCustomerCtrl, shown in the following excerpt. We use the $routeParams service in the new controller to get access to the values passed as path parameter arguments in the URL.
				}).when('/addedCustomer/:customer/:city', {
					templateUrl: 'partials/addedCustomer.html',
					controller: 'AddedCustomerCtrl'
				});
				/* chapter4/controllers.js excerpt */
				helloWorldControllers.controller('AddedCustomerCtrl',
					['$scope', '$routeParams',
					 function AddedCustomerCtrl($scope, $routeParams) {
						$scope.customerName = $routeParams.customer;
						$scope.customerCity = $routeParams.city;
				}]);	

JS Test Driver
	NetBeans has a great testing environment for both JS Test Driver and Karma. We will focus first on JS Test Driver for unit testing. We will then take a look at Karma for unit testing.

	The rest of this chapter will cover setting up a test environment and testing AngularJS controllers. We will focus first on setting up JS Test Driver for unit testing. 

		1) Download the JS Test Driver JAR.
		2) In the Services tab, right-click “JS Test Driver” and click “Configure”. 
		3) Select the location of the JS Test Driver JAR just downloaded and choose the browser of your choice. 
		4) Right-click the project node, then click “New”→“Other”→“Unit Tests.” 
		5) Select “jsTestDriver Configuration File” and click “Next.” 
		6) Make sure the file is placed in the 'config' subfolder. 
		7) Make sure the checkbox for “Download and setup Jasmine”. 
		8) Click “Finish.” 
		9) Right-click the project node, click Properties, and select “JavaScript Testing.” 
		10) Select “jsTestDriver” from the drop-down box.

	Inside the JS Test Driver configuration file, we specify the server URL that is used by JS Test Driver. We also specify the needed library files in the load section of the file, along with the locations of our JavaScript files and test scripts.
				/* chapter4/jsTestdriver.conf */
				server: http://localhost:42442
				load:
				- test/lib/jasmine/jasmine.js
				- test/lib/jasmine-jstd-adapter/JasmineAdapter.js
				- public_html/js/libs/angular.min.js
				- public_html/js/libs/angular-mocks.js
				- public_html/js/libs/angular-cookies.min.js
				- public_html/js/libs/angular-resource.min.js
				- public_html/js/libs/angular-route.min.js
				- public_html/js/*.js
				- test/unit/*.js
				exclude:
	Notice we’ve added angular-mocks.js to the list of required AngularJS library files. That file is needed for unit testing AngularJS applications. So, before continuing, add the angular-mocks.js file to the js/libs folder

	Creating Test Scripts
		Next, create a new JavaScript file in the unit subfolder of the newly created Unit Test folder. Name the new file controllerSpec.js. The contents of the controllerSpec.js file are shown next. Our test script filename will end with Spec. The file specifies a standard set of unit tests commonly used to test AngularJS controllers. Notice that we have a test for each of our controllers defined in the controllers.js file 
			describe('Hello World', function(){
			    beforeEach(module('helloWorldApp'));
			    describe('MainCtrl', function(){
			        var scope, ctrl;
			        beforeEach(inject(function($rootScope, $controller){ 
			            scope = $rootScope.$new();
			            ctrl = $controller('MainCtrl', {$scope: scope});
			        }));
			        it('should create initialed message', function(){
			            expect(scope.message)
			                    .toEqual("Hello World, White spaces make a difference");
			        });
			    }); 
			    describe('ShowCtrl', function(){
			        var scope, ctrl;
			        beforeEach(inject(function($rootScope, $controller){
			            scope = $rootScope.$new();
			            ctrl  = $controller('ShowCtrl', {$scope: scope});
			        }));
			        it('should create initialed message', function(){
			            expect(scope.message).toEqual("Show The World we here homie");
			        });
			    });
			    describe('CustomerCtrl', function(){
			        var scope, ctrl; 
			        beforeEach(inject(function($rootScope, $controller){
			            scope = $rootScope.$new();
			            ctrl  = $controller('CustomerCtrl', {$scope: scope});
			        }));
			        it('should create intialed message', function(){
			            expect(scope.customerName).toEqual("Hakeem's Bean Pies");
			        });
			    });
			}); 
		This test script uses Jasmine as the behavior-driven development framework for testing our code. We will use Jasmine for all our test scripts in this book.

	Testing with JS Test Driver
		Now to actually test the controllers we’ve defined, just right-click the project node and select “Test” from the menu. If your project is configured correctly, you should see a success message for all three controllers that were tested.

		<I had an extreme amount of trouble getting this to work. I'm assuming it's because I don't know enough about javaScript or the NetBeans IDE in general.  My project file was jacked up, making references to node.js. I fixed that, I kept getting an error that it couldn't find the scope variables I was creating. Finally, I had enough. I just imported the code from the book and moved on.  I will pick up a JS book later. Until then, learning the AngularJs framework, how it flows will have to be enough.>

	Testing with Karma
		Karma is a new and fun way to unit test AngularJS applications. We will use Karma here to test the controllers that we tested earlier.

		Installing Karma
			Karma runs on Node.js, so first you must install Node.js if it’s not already installed. You’ll also need to install the Node.js package manager (npm) on your system. npm is a command-line tool used to add the needed Node.js modules to a project.

			Now, in the root of the Chapter 4 project, create a JSON file named package.json and add the following content. The package.json file is used as a configuration file for Node.js:
					{
						"name": "package.json",
						"devDependencies": {
							"karma": "*",
							"karma-chrome-launcher": "*",
							"karma-firefox-launcher": "*",
							"karma-jasmine": "*",
							"karma-junit-reporter": "*",
							"karma-coverage": "*"
						}
					}

			Type this command to actually install the Node.js dependencies defined in the package.json file:
					npm install

			Now install the Karma command-line interface (karma-cli) by typing the following command:
					npm install -g karma-cli
			Make sure to record the location where karma-cli was installed. You will need the location later.

		Karma Configuration
			Next, create a new Karma configuration file named karma.conf.js inside the project test folder.
						1. Right-click the project.
						2. Select “Properties.”
						3. Select “JavaScript Testing” from the list of categories.
						4. Select “Karma” as the testing provider.
						5. Select the location of the karma-cli tool installed earlier.
						6. Select the location of the karma.conf.js file just created.
						7. Select “OK.”			
		Running Karma Unit Tests
			Now to actually run the unit tests (using the test specification written earlier) under Karma, right-click the project and select “Test” from the menu. Karma will start. You should see both Chrome and Firefox browser windows open. The NetBeans test results window should open and display three passed tests for Chrome and three passed tests for Firefox.
*************************************************************
*							    *
*							    *
*							    *
****    Chapter 5 - AngularJS Views and Bootstrap [pg100]****
We will now start a new AngularJS project that uses public REST services created especially for this book. We will start off by building the views and the controllers for those views. 

Twitter Bootstrap is a free collection of HTML and CSS templates. We will build the
AngularJS views with the help of Twitter Bootstrap to help cut development time. Once we have the views and controllers in place and understand their operation, we will focus on the model and REST services.

AngularJS Templates
	AngularJS views are defined by building templates (partials). Views in AngularJS are composed of HTML code with directives added, such as the ng-model directive shown previously. AngularJS builds the views dynamically at runtime by merging the templates with the properties passed to the templates in the $scope object. The end result is pure HTML code bound to the ng-view directive.


Adding a New Blog Controller
	The following code fudefines the blogControllers module and the BlogCtrl controller for that module.
			/* chapter5/controllers.js */
			'use strict';
			/* Controllers */
			var blogControllers =
			angular.module('blogControllers', []);
			blogControllers.controller('BlogCtrl', ['$scope',
				function BlogCtrl($scope) {
				$scope.blogArticle =
					"This is a blog post about AngularJS.
					We will cover how to build a blog and how to add
					comments to the blog post.";
			}]);

	Next is the code for the app.js file that starts the booting process for the blog application. We define 'ngRoute' and 'blogControllers' as dependencies of the application at startup time, using inline array annotations. The two dependencies are injected into the application using DI and are available throughout the application when we need them. Any controllers attached to the blogControllers module are accessible to the 'blogApp' module (the AngularJS application):
			/* chapter5/app.js */
			'use strict';
			/* App Module */
			var blogApp = angular.module('blogApp', [
				'ngRoute',
				'blogControllers'
			]);
			blogApp.config(['$routeProvider', '$locationProvider',
				function($routeProvider, $locationProvider) {
				$routeProvider.
				when('/', {
				templateUrl: 'partials/main.html',
				controller: 'BlogCtrl'
			});

			$locationProvider.html5Mode(false).hashPrefix('!');
			}]);
	The routes are defined in the application configuration block. We define BlogCtrl as the controller and 'partials/main.html' as the template used for the main route.

Adding a New Blog Template
	 Add a new HTML page named main.html in the partials folder. 

Twitter Bootstrap
	 If you run into JavaScript errors related to Twitter Bootstrap, you can easily replace the bootstrap.min.js file with the nonminified bootstrap.js file.

	 The nonminified version of the file allows the developer to place breakpoints in the Bootstrap JavaScript file and debug any related issues.

	 First, we need to add three more folders and some additional Twitter Bootstrap files to the project. We will add all the Bootstrap files here, although much of Bootstrap is not actually used in this project. Do the following:
		1. Add a subfolder named css under the Site Root folder.
		2. Add a subfolder named fonts under the Site Root folder.
		3. Add a subfolder named lib-css under the Site Root folder.
		4. Copy the bootstrap-theme.min.css and bootstrap.min.css files into the lib-css folder.
		5. Copy the following files to the fonts folder:
			a. glyphicons-halflings-regular.eot
			b. glyphicons-halflings-regular.svg
			c. glyphicons-halflings-regular.ttf
			d. glyphicons-halflings-regular.woff
		6. Add the two lines of code shown next to the index.html file. These two lines are all that we need to make use of Twitter Bootstrap:
					<!-- chapter5/index.html excerpt -->
					<link rel="stylesheet" href="lib-css/bootstrap.min.css" media="screen"/>
					<script src="js/libs/bootstrap.min.js"></script>
	The added CSS files and fonts will give us access to many time-saving features of Twitter Bootstrap. 

Adding a Bootstrap Menu
	The following are the contents of the menu.html file. Most of the code shown is clearly explained on the Bootstrap project site.

	The styles added to the menu here are defined in the bootstrap.min.css file added in the previous section. Then, construct your menu.html file.

	Add the menu.html file inside the 'main.html' file. The first line shows the needed addition to main.html. As you see, we use the 'ng-include' directive to include the menu template inside the main template. This approach allows us to keep the menu completely separate from the other templates. Using this approach makes the code base easy to maintain and understand.
		<!-- chapter5/main.html -->
		<div ng-include src="'partials/menu.html'"></div>
		{{blogArticle}}	

Adding Mock Blog Data
	We will modify the BlogCtrl controller and set a list of blog posts as a scope property named blogList. The JSON list represents the data that will eventually be retrieved from a REST service. 

	For now, however, we will just hardcode the JSON into the controller as mock data. There are more advanced ways to add mock data to an AngularJS application, but that is beyond the scope of this book

	There is no presentation logic and no data formatting in the controller. The date is sent to the view as a long value. Trying to format the date in the controller would be an incorrect design that shouldn’t be used. AngularJS has many features that make formatting and presenting data easy.

Using CSS3 to Style the Page
	Create a new CSS file named style.css. Now modify the index.html file, adding the line shown here to load the newly created CSS file:
				<link rel="stylesheet" href="css/styles.css" media="screen"/>

Adding Styles and Presentation Logic
	You must modify the main.html template to make use of the new styles and to add proper presentation logic for displaying blog posts and formatting data. The second line, <div id="container" class="container">, sets up a Bootstrap container and is standard practice with Twitter Bootstrap:
				<div ng-include src="'partials/menu.html'"></div>
				<div id="container" class="container">
				    <div class="blog-post-label">Blog Posts</div>
				    
				    <div class="post-wrapper">
				        
				        <div ng-repeat="blogPost in blogList">
				            <div class="blog-post-outer">
				                <div class="blog-intro-text">
				                    Posted: {{blogPost.date | date:'MM/dd/yyyy @ h:mma'}}
				                </div>
				                <div class="blog-intro-text">
				                    {{blogPost.introText}}
				                </div>
				                <div class="blog-read-more">
				                    <a href="#!blogPost/{{blogPost._id}}">
				                        Read More
				                    </a>
				                </div>
				            </div>
				        </div>
				        
				    </div>
				    
				</div>

	The Bootstrap container handles much of the page styling for various screen sizes to make the page responsive for any screen size on any device.

	The line <div ngrepeat="blogPost in blogList"> is very important to understanding AngularJS views. The directive ng-repeat works like a for loop, iterating over the list of blog posts in the scope property blogList.

	Each iteration through the list gives access to each item in the list through the variable 'blogPost'. Another line that is very important is the HTML template binding {{blogPost.date | date:'MM/dd/yyyy @ h:mma'}}, which allows us to format the date in the view, where it should be formatted. 

Viewing the Blog Post
	To add a controller, route, and view to display the individual blog post when a user clicks on the “View More” link.  First append this CSS code to the end of the styles.css file:

	Add code to the bottom of the controllers.js file. Next, add a new template file named 'blogPost.html' in the partials folder. Replace the generated code with the code shown here:

				<div ng-include src="'partials/menu.html'"></div>

				<div id="container" class="container">
				    <div class="blog-post-label">Blog Entry</div>
				    
				    <div class="blog-entry-wrapper">
				        
				        <div class="blog-intro-text">
				            Posted: {{blogEntry.date| date:'MM/dd/yyyy @ h:mma'}}
				        </div>
				        
				        <div class="blog-entry-outer">
				            {{blogEntry.blogText}}
				        </div>
				        
				        <div class="blog-comment-wrapper">
				            <div class="blog-comment-label">Blog Comments</div>
				            
				            <div class="blog-entry-comments" ng-repeat="comment in
				                blogEntry.comments">
				                {{comment.commentText}}
				            </div>
				        </div>
				        
				    </div>
				    
				</div>

	And add this code to the route provider section of app.js.
		.when('/blogPost/:id', {
			templateUrl: 'partials/blogPost.html',
			controller: 'BlogViewCtrl'

	If you look at the route definition, you’ll see the 'id' passed as a path parameter argument. Look at the new controller and you can see how we handle the id parameter  [var blogId = $routeParams.id;]. Since we do not yet have REST services in place, we hardcoded the JSON for the two blog posts into the controller. 

	Once we retrieve the passed id from $routeParams, we use that to determine which blog entry to set as a scope property. Notice that we never actually set a scope property until we know which blog entry gets sent to the view.

	You should never add properties to the scope that are not needed in the view.

Testing with Karma
		From the root of the project, create a JSON file named package.json and add the following contents.

		The package.json file is used as a configuration file for Node.js. Now type the following command to install the Node.js dependencies defined in the package.json file.
					npm install

*************************************************************
*							    *
*							    *
*							    *
****    Chapter 6 - AngularJS and REST Services   [pg128]****
The business logic for AngularJS applications should always be placed in REST services whenever possible. 

As AngularJS evolves over the next few years, it is very possible that most AngularJS applications will be rewritten. This means that any business logic placed inside an AngularJS application will need to be rewritten as well. 

REST services may undergo upgrades and modifications, but a complete service rewrite is unlikely in most casesThe best place for business logic is the place that will undergo the least amount of change and be available to all types of applications, now and in the future.

REST Services
	REST (REpresentational State Transfer) services allow for a “separation of concerns.” REST services are not concerned with the user interface or user state, and clients that use REST services are not concerned with data storage or business logic.

	REST services should be stateless. A REST service should never hold data in a session variable. All information needed for a REST service call should be contained in the request and header passed from the client to the service.

	Any state should be held in the client and not in the service. There are many ways to hold state in an AngularJS application, including local storage, cookies, or cache storage.

	A REST web service is said to be RESTful when it adheres to the following constrants:
			- It’s URL-based (e.g., http://www.micbutton.com/rs/blogPost).
			- It uses an Internet media type such as JSON for data interchange.
			- It uses standard HTTP methods (GET, PUT, POST, DELETE).

	The following is the standard way that HTTP methods should be used with REST services:
			- POST should be used to:
				a. Create a new resources.
				b. Retrieve a list of resources when a large amount of request data is required to be passed to the service.
			- PUT should be used to update a resource.
			- GET should be used to retrieve a resource or a list of resources.
			- DELETE should be used to delete a resource.

AngularJS and REST Services
	AngularJS REST service calls are asynchronous Ajax calls based on the $q service’s promise and deferred APIs. Making asynchronous Ajax REST service calls is not specific to AngularJS or any other client-side JavaScript framework. Many libraries provide Ajax functionality, including jQuery, Dojo, and others.

Ways to Create AngularJS Services
	There are three ways to create and register services in AngularJS. They are as follows:
			- Using the 'service' function
			- Using the 'provider' function
			- Using the 'factory' function

	Here’s how to create a service with the service function (we will not use this method to create services in this book)
				var blogServices = angular.module('blogServices', ['ngResource']);
				blogServices.service('BlogPost', […]
	
	You can also create services with the provider function, as shown here:
				/* chapter6/ provider function */
				var blogServices = angular.module('blogServices', ['ngResource']);
				blogServices.provider('BlogPost', […]
	
	The third way to create services in AngularJS is with the factory function. This is the most commonly used method, and the method we will use to create AngularJS services throughout this book:
				var blogServices = angular.module('blogServices', ['ngResource']);
				blogServices.factory('BlogPost', […]

	We will now look at how to connect to REST services in AngularJS, although we will not actually implement the service code in our blog application until later. We need to get a good theoretical understanding of AngularJS services before we start coding. Once we have that understanding, we will be set for coding.

Ways to Communicate with REST Services
	There are currently two ways to communicate with REST services using AngularJS:
		The $http service
			This service provides low-level interaction with REST services using the browser’s XMLHttpRequest object.

		The $resource object
			This object provides a high-level approach to interacting with REST services, simplifying the process considerably.

	We will focus mostly on using the $resource object for communicating with REST services. We will use the $http service in later chapters for handling Basic Authentication headers.

	The following code shows how to define an AngularJS service that can be used to interact with a REST service. Notice that we pass the REST service URL to the $resource object. 

	The methods defined match the REST services that are defined on that particular URL. Once the 'BlogPost' service is defined, it can be used like a standard JavaScript object to access the different REST services defined on this URL.
				/* chapter6/services.js */
				'use strict';

				/* Services */
				var blogServices = angular.module('blogServices', ['ngResource']);
				
				blogServices.factory('BlogPost', 
					['$resource',
					function($resource) {
						return $resource("http://www.micbutton.com/rs/blogPost", {}, {
							get: {method: 'GET', cache: false, isArray: false},
							save: {method: 'POST', cache: false, isArray: false},
							update: {method: 'PUT', cache: false, isArray: false},
							delete: {method: 'DELETE', cache: false, isArray: false}
						});
				}]);
	Using the $resource object is by far the easiest way to call REST services.

	As you can see from this example, the AngularJS service code is straightforward and really fairly uncomplicated. Even when many services are defined, the services.js file is relatively simple.

	Using the '$http' service would require many more lines of code related to REST service calls than we need using the $resource object. 

Updating the Project for REST
	Before we can use our service, the new services.js file must be loaded at runtime and the new services module, blogServices, must be specified as a dependency of the application at startup time. Here is the line that should be added to the index.html file to load the services.js file:
				/* chapter6/index.html excerpt */
				<script src="js/services.js"></script>

	The following code shows how we use inline annotations to add the new BlogServices module as a dependency of the application at startup time. Once the new module is added here, the services defined on the module can be used by any controller in the application:
				var blogApp = angular.module('blogApp', [
					'ngRoute',
					'blogControllers',
					'blogServices'
				]);

REST Services and Controllers
	Now let’s look at how to use the BlogPost service inside the BlogViewCtrl controller. First we must define the service as a requirement of the controller, as shown here. We then make a call to the get method and pass the id as an argument. We also define two callback functions, success and error (if you do not understand JavaScript callback functions, now would be a good time to stop and research how they work):
				blogControllers.controller('BlogViewCtrl',
					['$scope', '$routeParams', 'BlogPost',
					function BlogViewCtrl($scope, $routeParams, BlogPost) {
						var blogId = $routeParams.id;

						BlogPost.get({id: blogId},
							function success(response) {
								console.log("Success:" + JSON.stringify(response));
								$scope.blogEntry = response;
							},
							function error(errorResponse) {
								console.log("Error:" + JSON.stringify(errorResponse));
							}
						);
				}]);

	When a call is made to the BlogViewCtrl controller, the id is retrieved from $routeParams. A call is then made to the get method of the BlogPost service, passing the id as an argument. 

	At that point, the call to the controller completes. Theoretically we don’t know when the REST service call will return results, but when it does, either the success callback function or the error callback function will be called. 

	If the REST service call fails, the code inside the error callback function should handle the error condition. If the REST service call is successful, the code inside the success callback function handles the success functionality.

The JSON Response
	If the REST service call is successful, we set the JSON returned as the value of a scope property named blogEntry. The property is at that point bound to the view, and AngularJS updates the view with the new values that were retrieved from the REST service call.

	If the REST service call fails, the screen is not updated, but we log the error to the console to help diagnose the failure.

	The JSON response object returned from a successful call looks like this:
			{ "chapter: 6,"JSON": "response"}
			
			{
				"_id":1,
				"date":1400623623107,
				"introText":"This is a blog post about AngularJS. We will cover how to build",
				"blogText":"This is a blog post about AngularJS. We will cover how to build a blog and how to add comments to the blog post.",
				"comments":[
					{
						"commentText":"Very good post. I love it."
					},
					{
						"commentText":"When can we learn services."
					}
				]
			}

List Services
	If we wanted a list of blog posts, We could define the following REST service: GET: http://www.micbutton.com/rs/blogList. we would define that service in the services.js file. Notice that we specify 'isArray: true'. This defines the service as returning a list and not an individual resource:
				blogServices.factory('BlogList', 
				    ['$resource',
				    function($resource) {
				        return $resource(
				            "http://nodeblog-micbuttoncloud.rhcloud.com/NodeBlog/blogList", 
				            {}, 
				            {
				                get: {method: 'GET', cache: false, isArray: true}
				        });
				}]);

	Following is the controller code used to access the BlogList service. We inject the service into the controller as we did earlier, and like before, we pass success and error callback functions to the service call.
				blogControllers.controller('BlogCtrl', 
			    ['$scope', 
			    'BlogList',
			    function BlogCtrl($scope, BlogList) {
			        BlogList.get({},
			            function success(response) {
			                console.log("Success:" + JSON.stringify(response));
			                $scope.blogList = response;
			            },
			            function error(errorResponse) {
			                console.log("Error:" + JSON.stringify(errorResponse));
			            }
			        );
			}]);
*************************************************************
*							    *
*							    *
*							    *
****    Chapter 7 - AngularJS Models   [pg147]       ********
AngularJS models are held in the $scope object. In AngularJS, '$scope' is used to gain access to the model related to a particular controller. '$scope' is a child scope of '$rootScope'.

$rootScope is a parent scope that can be used to save and access model properties that span multiple controllers. The use of '$rootScope' is highly discouraged in most designs, however. There is only one '$rootScope' in an application. 

A properly designed AngularJS application will have little or no use for '$rootScope' to store model properties. In this chapter we will focus only on '$scope', used to store the model retrieved from REST services.

Public REST Services
	The following excerpt shows how AngularJS services access the REST services used. 
				/* chapter7/services.js excerpt */
				$resource(
				"http://nodeblog-micbuttoncloud.rhcloud.com/NodeBlog/blog/:id"
				...
				$resource(
				"http://nodeblog-micbuttoncloud.rhcloud.com/NodeBlog/blogList"
	The complete modified services.js file is shown here: 
				var blogServices = angular.module('blogServices', ['ngResource']);
				blogServices.factory('BlogPost', 
				    ['$resource',
				    function($resource) {
				        return $resource("http://www.micbutton.com/rs/blogPost", {}, {
				            get:       {method: 'GET', cache: false, isArray: false},
				            save:     {method: 'POST', cache: false, isArray: false},
				            update:    {method: 'PUT', cache: false, isArray: false},
				            delete: {method: 'DELETE', cache: false, isArray: false}
				        });
				}]);
				blogServices.factory('BlogList', 
				    ['$resource',
				    function($resource) {
				        return $resource(
				            "http://nodeblog-micbuttoncloud.rhcloud.com/NodeBlog/blogList", 
				            {}, 
				            {
				                get: {method: 'GET', cache: false, isArray: true}
				        });
				}]);


Changes to the Controllers
	The e services needed for each individual controller are injected and made accessible for that particular controller to use.

	The blog ID is passed as a path parameter argument to the BlogPost service. A path parameter is used because we defined /:id at the end of the BlogPost service URL in the services.js file.

	If we removed the /:id from the end of the service URL, AngularJS would pass the value as a query parameter argument instead.









http://localhost:8383/AngularJsBlogChapter7/index.html#!/




UTF-8 is a character coding that has support for many alphabets, including non-western ones. You’ve probably seen other character sets used in the past, but UTF-8 is being promoted as the new standard. And it’s way shorter and easier to remember than previous character encodings.


Function declarations can appear anywhere
in your script. You can declare a function below
where you use it if you want. This works because
when you first load your page, the browser parses
all the JavaScript in the page (or in the external
file) and sees the function declaration before it
starts executing the code. You can also put your
global variable declarations anywhere in your script,
although we recommend declaring all your global
variables at the top of your files so they’re easy to
locate.
One thing to keep in mind when using more than
one external JavaScript file is that if you have two
functions in different files named the same thing, the
function that the browser sees last will be the one
that is used. 


Latitude and Longitude Closeup
	You’ve probably seen latitude and longitude specfied in both degrees/minutes/seconds, such as (47˚38’34’’, 122˚32’32’’), and in decimal values, such as (47.64, -122.54). With the Geolocation API we always use decimal values. If you need to convert degrees/minutes/seconds to decimal, you can use this function:
			function degreesToDecimal(degrees, minutes, seconds) {
			return degrees + (minutes / 60.0) + (seconds / 3600.0);
			}

How the Geolocation API determins your location
	All browsers (in devices and on your desktop) are using a few different ways to determine where you are, some more accurate than others. Let’s take a look:

	Smartphones have GPS built right into the phone. Global Positioning System, supported by many newer mobile devices, provides extremely accurate location information based on satellites. Location data may include altitude, speed and heading information. To use it, though, your device has to be able to see the sky, and it can take a long time to get a location. GPS can also be hard on your batteries.

	Location information based on your IP address uses an external database to map the IP address to a physical location. Often IP addresses are resolved to locations such as your ISP’s local office. Think of this method as being reliable to the city or sometimes neighborhood level.

	Cell phone triangulation figures out your location based on your distance from one or more cell phone towers (obviously the more towers, the more accurate your location will be). This method can be fairly accurate and works indoors (unlike GPS); it also can be much quicker than GPS. Then again, if you’re in the middle of nowhere with only one cell tower, your accuracy is going to suffer.

	WiFi positioning uses one or more WiFi access points to triangulate your location. This method can be very accurate, works indoors and is fast. Obviously it requires you are somewhat stationary (perhaps drinking a venti iced tea at a coffee house).

	 Based on the accuracy, you can determine how useful the location is going to be for you. Stay tuned — we’ll get back to accuracy a little bit later

	 https://developers.google.com/maps/documentation/javascript/?csw=1









<script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAaRHLJ5ZO49joDJk8W3ZJxM9lheHkM9Wc&callback=initMap" type="text/javascript"></script>



Keychain Access
Open Keychain Access app
http://www.mactip.net/how-to-find-a-saved-wi-fi-password-on-the-mac/
Open Keychain Access app. It is located in the Applications > Utilities folder.
Select the System keychain in the left menu bar, and select Passwords from the category menu. This will filter the keychains to just your stored passwords.




Failed to load http://wickedlysmart.com/ifeelluckytoday/: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost:63342' is therefore not allowed access.


If you want to make further changes to your Apache system or user config files, you will need to restart the Apache server with:
			sudo apachectl graceful


https://discussions.apple.com/docs/DOC-11238
	























Brightcove, Ooyala, & Kaltura















