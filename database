I was trying to get the MySql to start from "System Preferences" -> "mysql" -> 
	"start MySql Server". I ran into this issue: Warning the 
	/user/local/mysql/data directory is not owned by the mysql user. So, I 
	found this resoution.
		sudo chown -RL root:mysql /usr/local/mysql
		sudo chown -RL mysql:mysql /usr/local/mysql/data
		sudo /usr/local/mysql/support-files/mysql.server start
	But that didn't work as epxected i got the error below.
I saw: 'ERROR 2002 (HY000): Can't connect to local MySQL server through socket 
	'/var/run/mysqld/mysqld.sock' (2)'. Stackoverflow said I should try the following 
	below. See, https://serverfault.com/questions/751277/mysql-daemon-lock-issue from 
	https://stackoverflow.com/questions/34954455/mysql-daemon-lock-issue
At first i Add skip-external-locking to /usr/local/Cellar/mysql/5.7.18_1/.bottle/etc/my.cnf 
	under the [mysqld] section:
	https://stackoverflow.com/questions/34954455/mysql-daemon-lock-issue
		skip-external-locking
MySQL Help
B.5.3.2.1 Resetting the Root Password: Windows Systems - 
	https://dev.mysql.com/doc/refman/5.7/en/resetting-permissions.html. Use the following 
	procedure to reset the password for the MySQL 'root'@'localhost' account. 
Create a text file containing the password-assignment statement on a single line. Replace the 
	password with the password that you want to use.
		MySQL 5.7.6 and later:
		ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass';	
	Save the file. This example assumes that you name the file 
		/Users/syeedode/junk/mysql_rootPassword.txt
	Start the MySQL server with the special --init-file option (notice that the backslash 
		in the option value is doubled):
			[20170930-12:34:52 syeedode:/usr/local/Cellar/mysql] $ mysqld 
				--init-file=/Users/syeedode/junk/mysql_rootPassword.txt
	You should now be able to connect to the MySQL server as root using the new password. Stop 
		the MySQL server and restart it normally.
	If the ALTER USER statement fails to reset the password, try repeating the procedure using 
		the following statements to modify the user table directly:
			UPDATE mysql.user
				  SET authentication_string = PASSWORD('MyNewPass')
				, password_expired = 'N'
			WHERE User = 'root' AND Host = 'localhost';
			FLUSH PRIVILEGES;			
	To create a user and DB now: 
			GRANT ALL ON vsearchlogDB.* 
				TO 'vsearch' 
			IDENTIFIED BY 'vsearchpasswd';
	Finally, attempt to add another privilege user.  I'm trying to allow the `syeedode` user to 
		kickoff my sql.  This, I'm hoping, will allow the 
*
*
*
*				Dirty Reads:		Nonrepeatable (Fuzzy) Reads:	Phantom Reads:
				TxA reads data that	TxA reads datq once. When it	TxA reads data once. When it
				TxB put there but has	rereads the same data, TxB has	rereads the same data, TxB has
				not yet commited.	removed the data or modified 	has commited more rows to the 
							it (via commits).		data
				---------------------	------------------------------	------------------------------
Read Uncommitted:		Possible		Possible			Possible

Read Committed:			Not possible 		Possible			Possible

Repeatable Reads:		Not possible 		Not possible 			Possible

Seralizable:			Not possible 		Not possible 			Not possible

Optimistic Locking
	Optimistic Locking is a strategy where you read a record, take note of a version number (other methods to do this involve dates, timestamps or checksums/hashes) and check that the version hasn't changed before you write the record back. When you write the record back you filter the update on the version to make sure it's atomic. (i.e. hasn't been updated between when you check the version and write the record to the disk) and update the version in one hit.

	If the record is dirty (i.e. different version to yours) you abort the transaction and the user can re-start it.

	This strategy is most applicable to high-volume systems and three-tier architectures where you do not necessarily maintain a connection to the database for your session. In this situation the client cannot actually maintain database locks as the connections are taken from a pool and you may not be using the same connection from one access to the next.

Pessimistic Locking
	Pessimistic Locking is when you lock the record for your exclusive use until you have finished with it. It has much better integrity than optimistic locking but requires you to be careful with your application design to avoid Deadlocks. To use pessimistic locking you need either a direct connection to the database (as would typically be the case in a two tier client server application) or an externally available transaction ID that can be used independently of the connection.

	In the latter case you open the transaction with the TxID and then reconnect using that ID. The DBMS maintains the locks and allows you to pick the session back up through the TxID. This is how distributed transactions using two-phase commit protocols (such as XA or COM+ Transactions) work.
*
*
*
*
This information was gather from reading the Spring Framework Reference Documentation: Data access and transaction management section.  The focus of the notes is only on Transaction Management.  It a collection of notes, broken down by section.

https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#spring-data-tier
*
*
*
*
JDO - Java Data Objects
JTA - Java Transaction API (depends on JNDI)
JPA - Java Persistence API
*
*
*
*
17.2 Advantages of the Spring Framework’s transaction support model
17.2.1 Global transactions
	When transaction manager is handled by one framework/platform for all transactions, like EJB CMT.
17.2.2 Local transactions
	When transacton manager cannot work across multiple transaction resources 
17.2.3 Spring Framework’s consistent programming model
			Do you need an application server for transaction management?




17.3 Understanding the Spring Framework transaction abstraction (2 - 5)
	class PlatformTransactionManager
		TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
			TransactionStatus  // defines type and state of transaction
				boolean isNewTransaction();
				boolean hasSavepoint();
				void setRollbackOnly();
				boolean isRollbackOnly();
				void flush();
				boolean isCompleted();
			TransactionDefiniton 
				Isolation:, Propagation, Timeout, Readonly
		void commit(TransactionStatus status) throws TransactionException;
		void rollback(TransactionStatus status) throws TransactionException;
	PlatformTransactionManager implementations normally require knowledge of the environment in 
		which they work: JDBC, JTA, Hibernate, and so on. 
	PlatformTransactionManager implementers are (not exhaustive list): 
		DataSourceTransactionManager, JtaTransactionManager, 	(depends on a dataSource object)
		HibernateTransactionManager				(depends on a sessionFactory object)




17.4 Synchronizing resources with transactions (2) [2 - 6]
	Discusses how application code creates, uses, reuses, and tears down a persistance api
		such as Hibernate, JDBC, JDO, or JTA
	Discusses how transaction synchronization is triggered (optionally) throught the relevant
		PlatformTransactionManager
17.4.1 High-level synchronization approach (2)
	Use a "transaction aware" template (JdbcTemplate, for example) that does teardown, setup 
		and transactioin synchronoization for you. 
17.4.2 Low-level synchronization approach (2 - 5)
	Use a  DataSourceUtils (for JDBC), EntityManagerFactoryUtils (for JPA), 
		SessionFactoryUtils (for Hibernate), PersistenceManagerFactoryUtils (for JDO) to 
		manage the creation of connections directly. This code assignes the connection to an
		existing transcation.
17.4.3 TransactionAwareDataSourceProxy (6)
	Wraps an existing data source.  Only use if trying to get existing code to use spring
		managed transactions.  That's why this is a (virtual) proxy it is making the existing 
		datasource aware of Spring's transactions, see, Head First Design Patterns: Controlling 
		Object Access Page 45 for more on proxies types and their usages.




17.5 Declarative transaction management (6 - 7) [6 - 23]
	Unlike EJB CMT, which is tied to JTA, the Spring Framework’s declarative transaction 
		management works in any environment. It can work with JTA transactions or local 
		transactions using JDBC, JPA, Hibernate or JDO by simply adjusting the configuration 
		files
	The concept of rollback rules is important: they enable you to specify which exceptions 
		(and throwables) should cause automatic rollback. You specify this declaratively, in 
		configuration, not in Java code.
17.5.1 Understanding the Spring Framework’s declarative transaction implementation (7)
	Spring Framework’s declarative transaction support is enabled via AOP proxies.  An AOP proxy 
		in conjunction with a PlatformTransactionManager implementation drive transactions 
		around method invocations.
17.5.2 Example of declarative transaction implementation (7 - 10)
	1) Create a PlatformTransactionManager 
		<bean id="txManager" class="DataSourceTransactionManager">
			<property name="dataSource" ref="dataSource"/>
		</bean>
	2) Create an AOP advice 
		<tx:advice id="txAdvice" transaction-manager="txManager">
			<tx:attributes>
			 	<!-- all methods starting with 'get' are read-only -->
 				<!-- other methods use the default transaction settings (see below) -->
				<tx:method name="get*" read-only="true"/>
				<tx:method name="*"/>
 			</tx:attributes>
 		</tx:advice>
	3) Create an AOP aspect config (advice/pointcut) 
 		<!-- ensure that the above transactional advice runs for any execution of an -->
 		<!-- operation defined by the FooService interface -->
		<aop:config>
			<aop:pointcut id="fooSerOp" expression="execution(* x.y.service.FooService.*(..))"/>
			<aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/>
		</aop:config>
	4) Run sample
		public final class Boot {
			public static void main(final String[] args) throws Exception {
				ApplicationContext ctx = 
					new ClassPathXmlApplicationContext("context.xml", Boot.class);
				FooService fooService = (FooService) ctx.getBean("fooService");
				fooService.insertFoo (new Foo());
			}
		}
17.5.3 Rolling back a declarative transaction (10 - 11)
	In its default configuration, the Spring Framework’s transaction only rollsback in the case
		of runtime, unchecked exceptions; that is, when the thrown exception is an instance or 
	 	subclass of RuntimeException.
	 You can configure exactly which Exception types mark a transaction for rollback, including 
	 	checked exceptions. You can also specify 'no rollback rules', if you do not want a 
	 	transaction, even for uncheckec exceptions.
		<tx:advice id="txAdvice" transaction-manager="txManager">
			<tx:attributes>
				<tx:method name="get*" read-only="true" rollback-for="NoProductInStockException"/>
				<tx:method name="updateStock" no-rollback-for="InstrumentNotFoundException"/>
				<tx:method name="*"/>
			</tx:attributes>
		</tx:advice>	 
17.5.4 Configuring different transactional semantics for different beans (11 - 13)
	You can configure an advice for no transaction support. Just add the advice to the <aop:config>
		<aop:config>
			<aop:pointcut id="defaultServiceOperation" 
				expression="execution(* x.y.service.*Service.*(..))"/>
			<aop:pointcut id="noTxServiceOperation" 
				expression="execution(* x.y.service.ddl.DefaultDdlManager.*(..))"/>
			<aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/>
			<aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/>
		</aop:config>	
		<tx:advice id="noTxAdvice">
			<tx:attributes>
				<tx:method name="*" propagation="NEVER"/> <!-- specifies no tx -->
			</tx:attributes>
		</tx:advice>
17.5.5 <tx:advice/> settings (13)
	These attributes are for the <tx:method/> tag only
		read-only
		rollback-for="Specified Checked or Unchecked Exception"
		no-rollback-for="Specified Checked or Unchecked Exception"
		propagation
		isolation
		timeout
17.5.6 Using @Transactional (14 - 17) [14 - 19]
	Simply add the following line to the application-context.xml
		<!-- enable the configuration of transactional behavior based on annotations -->
		<!-- a PlatformTransactionManager is still required -->
		<tx:annotation-driven transaction-manager="txManager"/>
	The @EnableTransactionManagement annotation provides equivalent support if you are using Java 
		based configuration. Simply add the annotation to a @Configuration class. See the javadocs 
		for full details.
	You can place the @Transactional annotation before an interface definition, a method on an 
		interface, a class definition, or a public method on a class.
	Spring recommends that you only annotate concrete classes (and methods of concrete classes).
					
	The proxy-target-class attribute controls what type of transactional proxies are created for 
		classes annotated with the @Transactional annotation. If proxy-target-class is set to true, 
		class-based proxies are created (i.e. it uses CGLIB to read the class not just the interface.
		The differnce is only the interface methods are gathered with JDK. The class methods may not
		be. If CGLIB (code geneartor library) is ued, all the class mehtods are proxied as well.). 
		If proxy-target-class is false or if the attribute is omitted, standard JDK interface-based 
		proxies are created.
	@EnableTransactionManagement and <tx:annotation-driven/> only looks for @Transactional on beans 
		in the same application context they are defined in.
	The most derived location takes precedence when evaluating the transactional settings for a 
		method.  The @Transactional annotation on the updateFoo(Foo) method in the same class takes 
		precedence.
			@Transactional(readOnly = true)
			public class DefaultFooService implements FooService {
				public Foo getFoo(String fooName) {
					// do something
				}

				// these settings have precedence for this method
				@Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
				public void updateFoo(Foo foo) {
					// do something
				}
			}

					@Transactional settings (17)
	value			Optional qualifier specifying the transaction manager to be used
	read-only
	rollback-for 		Specified Checked or Unchecked Exception
	no-rollback-for 	Specified Checked or Unchecked Exception
	propagation
	isolation
	timeout

					Multiple Transaction Managers with @Transactional (18)
	Allows two different datasources.

					Custom shortcut annotations (19)
17.5.7 Transaction propagation (19 - 20)
	Be aware of the difference between physical and logical transactions, and how the 
	 	propagation setting applies to this difference.

						Required (20)
	PROPAGATION_REQUIRED
		a logical transaction scope is created for each method upon which the setting is
			applied, with an  outer transaction scope being logically independent from 
			the inner transaction scope.
		in standard behavior,  all these scopes will be mapped to the same physical 
		 	transaction
		a rollback-only marker set in the inner transaction scope DOES affect the outer 
			transaction’s chance to actually commit (as you would expect it to).

						RequiresNew (20)
	PROPAGATION_REQUIRES_NEW
		uses a completely independent transaction for each affected transaction scope. 
			the underlying physical transactions are different and hence can commit or 
			roll back independently, with an 
		outer transaction NOT affected by an inner transaction’s rollback status.

						Nested (20)
	PROPAGATION_NESTED - JDBC ONLY
		uses a single physical transaction with multiple savepoints that it can roll back 
			to. Such partial rollbacks allow an inner transaction scope to trigger a 
			rollback for its scope, with the outer transaction being able to continue the 
			physical transaction despite some operations having been rolled back. This 
			setting is typically mapped onto JDBC savepoints, so will only work with JDBC 
			resource transactions. 
17.5.8 Advising transactional operations (21 - 23)
17.5.9 Using @Transactional with AspectJ (23)




17.6 Programmatic transaction management (24) [24 - 25]
17.6.1 Using the TransactionTemplate (24 - 25)
			Specifying transaction settings (25)
17.6.2 Using the PlatformTransactionManager (25)




17.7 Choosing between programmatic and declarative transaction management (26)





17.8 Transaction bound event (26)






17.9 Application server-specific integration (26 - 27)
17.9.1 IBM WebSphere (27)
17.9.2 Oracle WebLogic Server (27)






17.10 Solutions to common problems (27)






17.11 Further Resources (27)
*
*
*
*
*
*
*
*
*
*
*
This information was gathered from reading Hibernate's Annotations Documention, Mapping Entities:
	https://docs.jboss.org/hibernate/annotations/3.5/reference/en/html/entity.html. 
*************************************************************
*							    *
*							    *
*							    *
*** Chapter 2.2 - Mapping with JPA (Java Persistence Annotations) [pg1 - 25] ***
*****      Chapter 2.3 - Mapping Queries [pg25 - 29]    *******
*************************************************************
*							    *
*							    *
*							    *
** Chapter 2.4 - Hibernate Annotation Extensions [pg29 - 41] **
2.4.1. Entity
	@org.hibernate.annotations.Entity adds additional metadata that may be needed beyond what is defined in the standard @Entity

	@javax.persistence.Entity is still mandatory, @org.hibernate.annotations.Entity is not a replacement.
			dynamicInsert: allow dynamic SQL for inserts
			
			polymorphism: whether the entity polymorphism is of PolymorphismType.IMPLICIT (default) or PolymorphismType.EXPLICIT

			optimisticLock: optimistic locking strategy (OptimisticLockType.VERSION, OptimisticLockType.NONE, OptimisticLockType.DIRTY or OptimisticLockType.ALL)

			@org.hibernate.annotations.Proxy defines the laziness attributes of the entity. lazy (default to true) define whether the class is lazy or not. proxyClassName is the interface used to generate the proxy (default is the class itself).

			@org.hibernate.annotations.Where defines an optional SQL WHERE clause used when instances of this class is retrieved. 

			DDL refers to "Data Definition Language", a subset of SQL statements that change the structure of the database schema in some way, typically by creating, deleting, or modifying schema objects such as databases, tables, and views.

			Most Impala DDL statements start with the keywords CREATE , DROP , or ALTER.

			@org.hibernate.annotations.Check defines an optional check constraints defined in the DDL statetement. The CHECK constraint is used to limit the value range that can be placed in a column. If you define a CHECK constraint on a single column it allows only certain values for this column. If you define a CHECK constraint on a table it can limit the values in certain columns based on values in other columns in the row.
						CREATE TABLE Persons (
						    ID int NOT NULL,
						    LastName varchar(255) NOT NULL,
						    FirstName varchar(255),
						    Age int,
						    CHECK (Age>=18)
						);

			@OnDelete(action=OnDeleteAction.CASCADE) on joined subclasses: use a SQL cascade delete on deletion instead of the regular Hibernate mechanism.

	@org.hibernate.annotations.Table is a complement, not a replacement to @javax.persistence.Table. 

	Especially, if you want to change the default name of a table, you must use @javax.persistence.Table, not @org.hibernate.annotations.Table.

	@Table(appliesTo="tableName", indexes = { @Index(name="index1", columnNames={"column1", "column2"} ) } ) creates the defined indexes on the columns of table tableName. This can be applied on the primary table or any secondary table. 

	The @Tables annotation allows your to apply indexes on different tables. This annotation is expected where @javax.persistence.Table or @javax.persistence.SecondaryTable(s) occurs.

	Inner and Outer Joins from https://www.essentialsql.com/get-ready-to-learn-sql-server-14-introduction-to-outer-joins/ 
		Both inner and outer joins are used to combine rows from two or more tables into a single result. This is done by specifying how columns from each table are matched to one another.  The aim is to find equal values between tables, and include those matches.

		Inner joins don’t include non-matching rows. In its simplest case, where there is no join condition, an inner join would combine all rows from one table with those from another.  If the first table contained three rows, and the second, four, then the final result would contain twelve (3 x 4 = 12) !

		If a person has more than one phone number, then more than one match is made.  From this you can see we may get more rows returned than we have for each person. Conversely, if a person has no phone number, then there won’t be an entry in PersonPhone, and no match made.  That particular person won’t be included in the results, as only those with matches are included. Keep in mind the inner join only returns row where the match condition is true.  

		Let’s try an example. The {INNER JOIN} specifies [which tables to join] and the <match condition> for doing so.  The condition PH.Phone NumberTyeID = 3 limits the query to work numbers.
					SELECT   P.FirstName,
					         P.LastName,
					         P.Title,
					         PH.PhoneNumber
					FROM     [ Person.Person ] AS P
					         {INNER JOIN}
					         [ Person.PersonPhone ] AS PH
					         ON < P.BusinessEntityID = PH.BusinessEntityID
					         AND PH.PhoneNumberTypeID = 3 >
					ORDER BY P.LastName


		In this example, rows where the BusinessEntityID’s don’t match aren’t included.  This could be an issue if a person doesn’t have a phone number as those employees wouldn’t be on the list.

	Outer Joins
		If you wish to include these employees you can use an Outer join. Outer joins do include non matching rows. 

		The outer join will return every row from one specified table, even if the join condition fails. If the HR manager wanted to list every employee regardless of whether they had a work phone number, then using an outer join would make it so.

	Types of Outer Joins
		Left Outer Join – All rows from the left table are included, unmatched rows from the right are replaced with NULL values.

		Right Outer Join – All rows from the right table are included, unmatched rows from the left are replaced with NULL values.

		Full Outer Join – All rows from both tables are included, NULL values fill unmatched rows

	Left Outer Join
		Understand that when a {LEFT OUTER JOIN} is used, all rows for [the table] in the FROM clause are included in the result, even if a match isn’t found with the other table. When a match isn’t found, then a NULL is place in the column.
					SELECT   P.FirstName,
					         P.LastName,
					         P.Title,
					         PH.PhoneNumber
					FROM     [ Person.Person ] AS P
					         {LEFT OUTER JOIN}
					         Person.PersonPhone AS PH
					         ON P.BusinessEntityID = PH.BusinessEntityID
					         AND PH.PhoneNumberTypeID = 3
					ORDER BY P.LastName

		In this model, there is 1 Person to 0 or 1 Employees. To construct a list of ALL Person LastNames, yet, ALSO show JobTitle IF the Person is an Employee, we need a way of joining the two tables and include Person rows in the result, even if they don’t match Employee.

		This type of join is called a left outer join, as all the rows for the table from the left side of the JOIN keyword are included regardless of the match.
					SELECT person.Person.BusinessEntityID,
					       Person.Person.LastName,
					       HumanResources.Employee.NationalIDNumber,
					       HumanResources.Employee.JobTitle
					FROM   person.Person // return all person.Person rows
					LEFT OUTER JOIN
					      HumanResources.Employee
					      ON person.BusinessEntityID = Employee.BusinessEntityID
	Right Outer Join
		Below is our sample query written as a right outer join.  The key difference is that now we are going to return all records from the Employee table, which is the table to the right of the join keyword.  If a matching Employee record isn’t found, then NULL will be returned for BusinessEntityID and LastName.
					SELECT person.Person.BusinessEntityID,
					       Person.Person.LastName,
					       HumanResources.Employee.NationalIDNumber,
					       HumanResources.Employee.JobTitle
					FROM   person.Person
					RIGHT OUTER JOIN
					      HumanResources.Employee
					      ON person.BusinessEntityID = Employee.BusinessEntityID
      	This returns all records and no null values.  The data model is the reason why. There is 1 Person to 0..1 Employees.  That means if every Employee is a Person.  But a person may not be an Employee. If the Employee exists it has to be in the person table as well.

  	Left versus Right Outer Joins
  		There is no difference in functionality between a left outer join and a right outer join. Note in the two queries below, the table names are reversed so they are EXACTLY the same.
					SELECT person.Person.BusinessEntityID,
					       HumanResources.Employee.NationalIDNumber
					FROM   person.Person
					LEFT OUTER JOIN
					       HumanResources.Employee
					      ON person.BusinessEntityID = Employee.BusinessEntityID
  		Is exactly the same as: 
					SELECT person.Person.BusinessEntityID,
					       HumanResources.Employee.NationalIDNumber
					FROM   HumanResources.Employee
					RIGHT OUTER JOIN
					      person.Person
					      ON person.BusinessEntityID = Employee.BusinessEntityID

      	Using the LEFT OUTER JOIN may be more intuitive since thats where the from is located.

  	Full Outer Join
  		A full outer join is the combination of results from a left and right outer join.  The results returned from this type of join include all rows from both tables.  

  		Where matches occur, values are related.  Where matched from either table don’t, then NULL are returned instead. (Think the result from the no option comm Linux command.)
	
	@org.hibernate.annotations.Table can also be used to define the following elements of secondary tables:
			fetch: 
				If set to JOIN, the default, Hibernate will use an inner join to retrieve a secondary table defined by a class or its superclasses. 

				If set to JOIN, Hibernate will use outer join for a secondary table defined by a subclass. 

				If set to select then Hibernate will use a sequential select for a secondary table defined on a subclass, which will be issued only if a row turns out to represent an instance of the subclass. 

				If set to select, Inner joins will still be used to retrieve a secondary defined by the class and its superclasses.

			inverse: If true, Hibernate will not try to insert or update the properties defined by this join. Default to false.

			optional: If enabled (the default), Hibernate will insert a row only if the properties defined by this join are non-null and will always use an outer join to retrieve the properties.

			foreignKey: defines the Foreign Key name of a secondary table pointing back to the primary table.






















