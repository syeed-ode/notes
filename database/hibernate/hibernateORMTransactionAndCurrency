This information was gather from reading the Hibernate Documentation: Transactions and Concurrency section.  It a collection of notes, broken down by section.

https://docs.jboss.org/hibernate/orm/3.3/reference/en-US/html/transactions.html#transactions-optimistic


Chapter 11. Transactions and Concurrency
	The most important point about Hibernate and concurrency control is that it is easy to understand.

	Hibernate directly uses JDBC connections and JTA resources without adding any additional locking behavior.

	It is recommended that you spend some time with the JDBC, ANSI, and transaction isolation specification of your database management system.

	Hibernate does not lock objects in memory.
			Your application can expect the behavior as defined by the isolation level of your database transactions.

			Through Session, which is also a transaction-scoped cache,
					Hibernate provides repeatable reads for lookup by identifier and entity queries

					Hibernate does not provide reporting queries that return scalar values.

	Hibernate offers versioning for automatic optimistic concurrency control.

	Hibernate also offers: 
			using the SELECT FOR UPDATE syntax

			a (minor) API for pessimistic locking of rows

	The discussion of concurrency control in Hibernate begins with the granularity of 
			Configuration

			SessionFactory

			Session, as well as, 

			database transactions and

			long conversations.

11.1. Session and transaction scopes
	A SessionFactory is an expensive-to-create, threadsafe object, intended to be shared by all application threads.
			It is created once, usually on application startup, from a Configuration instance.

	A Session is an inexpensive, non-threadsafe object that should be used once and then discarded for: 
			a single request

			a conversation or 

			a single unit of work.

			A Session will not obtain a JDBC Connection, or a Datasource, unless it is needed.

			It will not consume any resources until used.

	A database transaction has to be as short as possible in order to reduce lock contention in the database.
			Long database transactions will prevent your application from scaling to a highly concurrent load.

			It is not recommended that you hold a database transaction open during user think time until the unit of work is complete.

					What is the scope of a unit of work?

					Can a single Hibernate Session span several database transactions, or is this a one-to-one relationship of scopes?

					When should you open and close a Session and how do you demarcate the database transaction boundaries?

					These questions are addressed in the following sections.


11.1.1. Unit of work - or, business transaction
	A unit of work is a design pattern which is a series of operations we wish to carry out against the database together.

	A unit of work is a design pattern described by Martin Fowler as “[maintaining] a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems.”

	Basically, a unit of work is a it is a transaction.

	Keep in mind fulfilling a unit of work will often span multiple physical database transactions. So really we are talking about a more abstract notion of a transaction.

	The term "business transaction" is also sometimes used in lieu of unit of work.

	Do not use the 'session-per-operation' antipattern':
			do not open and close a Session for every simple database call in a single thread.

			The same is true for database transactions. Database calls in an application are made using a planned sequence.
					Database calls in an application are grouped into atomic units of work.

					This also means that auto-commit after every single SQL statement is useless in an application as this mode is intended for ad-hoc SQL console work.

			Hibernate disables, or expects the application server to disable, auto-commit mode immediately.

			All communication with a database has to occur inside a transaction.

	'session-per-request' is the most common pattern in a multi-user client/server application.
			a request from the client is sent to the server, where the Hibernate persistence layer runs.

			A new Hibernate Session is opened, and all database operations are executed in this unit of work.

			On completion of the work, and once the response for the client has been prepared, the session is flushed and closed.

			Use a single database transaction to serve the clients request, starting and committing it when you open and close the Session.

			The relationship between the two is one-to-one and this model is a perfect fit for many applications.

	The challenge of 'session-per-request' lies in the implementation. Hibernate provides built-in management of the "current session" to simplify this pattern.
			Start a transaction when a server request has to be processed, and end the transaction before the response is sent to the client.

			Common solutions are 
				ServletFilter

				AOP interceptor with a pointcut on the service methods (this is done with spring annotations) or 

				a proxy/interception container (this is done with spring annotations or programatically as well).

			An EJB container is a standardized way to implement cross-cutting aspects such as transaction demarcation on EJB session beans, declaratively with CMT.
					EJB CMT is considered a global transaction manager.

					It is when transaction manager is handled by one framework/platform for all transactions.

			If you use programmatic transaction demarcation, for ease of use and code portability, use the Hibernate Transaction API.

	Your application code can access a "current session" to process the request by calling sessionFactory.getCurrentSession().
			You will always get a Session scoped to the current database transaction.

			This has to be configured for either resource-local or JTA environments.

	You can extend the scope of a Session and database transaction until the "view has been rendered". 
			This is especially useful in servlet applications that utilize a separate rendering phase after the request has been processed.

			Extending the database transaction until view rendering, is achieved by implementing your own interceptor.

			However, this will be difficult if you rely on EJBs with container-managed transactions.

			See the Hibernate website and forum for tips and examples relating to this 'Open Session in View' pattern.


11.1.2. Long conversations
	The session-per-request pattern is not the only way of designing units of work.
			Many business processes require a whole series of interactions with the user that are interleaved with database accesses.

			In web and enterprise applications, it is not acceptable for a database transaction to span a user interaction. 

			Consider the following example:
					The first screen of a dialog opens. 

					The data seen by the user has been loaded in a particular Session and database transaction. 

					The user is free to modify the objects.

					The user clicks "Save" after 5 minutes and expects their modifications to be made persistent. 

					The user also expects that they were the only person editing this information and, 

					That no conflicting modification has occurred.

	A single conversation spaning several database transactions is a unit of work called a 'long-running conversation' or 'application transaction' from the point of view of the user.

	There are many ways to implement this in your application.
			A first naive implementation might keep the Session and database transaction open during user think time.
					The locks held in the database to prevent concurrent modification and  

					The database locks guaranteeing isolation and atomicity.

					This is an anti-pattern, 
							since lock contention would not allow the application to scale with the number of concurrent users.

			You have to use several database transactions to implement the conversation.
					Maintaining isolation of business processes becomes the partial responsibility of the application tier.

					A single conversation usually spans several database transactions.

					It will be atomic if only one of these database transactions (the last one) stores the updated data.

					All others simply read data (for example, in a wizard-style dialog spanning several request/response cycles).

	A single conversation spaning several database transactions is easier to implement than it might sound

	Especially if you utilize some of Hibernate's features:
			Automatic Versioning: 		Hibernate can perform 
							automatic optimistic 
							concurrency control for 
							you. 
							
							It can automatically 
							detect if a concurrent 
							modification occurred 
							during user think time.
							
							Check for this at the 
							end of the conversation.
							
			Detached Objects: 		if you decide to use 
							the 
							'session-per-request' 
							pattern, all loaded 
							instances will be in 
							the detached state 
							during user think time.
							
							Hibernate allows you to 
							reattach the objects 
							and persist the 
							modifications. 
							
							The pattern is called 
							'session-per-request-with-detached-objects'. 
							
							Automatic versioning is 
							used to isolate 
							concurrent 
							modifications.

			Extended (or Long) Session: 	the Hibernate Session 
							can be disconnected 
							from the underlying 
							JDBC connection after 
							the database 
							transaction has been 
							committed and 
							reconnected when a new 
							client request occurs. 

									This pattern is known as 'session-per-conversation' and makes even reattachment unnecessary. 

									Automatic versioning is used to isolate concurrent modifications and 

									The Session will not be allowed to be flushed automatically, but explicitly.

	Both session-per-request-with-detached-objects and session-per-conversation have advantages and disadvantages.

	These disadvantages are discussed later in this chapter in the context of optimistic concurrency control.















11.1.3. Considering object identity
11.1.4. Common issues




















































