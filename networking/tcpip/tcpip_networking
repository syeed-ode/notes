Add 51 to the page to get the pdf location. A page references are in PDF pages.
*************************************************************
*							    *
*							    *
*							    *
toc: 19
pg496 - 560
*************************************************************
****          Chapter 14 - TCP/IP Networking          *******
*************************************************************
TCP/IP is the networking system that underlies the Internet, so devices that speak TCP/IP can all exchange data (“interoperate”) despite their many differences. 

TCP/IP and its relationship to the Internet
	Thel success of the Internet is due to the flexible design of TCP/IP and that tCP/IP is an open and nonproprietary protocol suite.

	Today’s Internet is a collection of private networks owned by Internet service providers (ISPs) that interconnect at many so-called peering points.

	Who runs the Internet?
		Current Internet governance is split into administrative, technical, and political wings, but the boundaries between these functions are often vague. The major players are listed below:
		 		ICANN (Internet Corporation for Assigned Names and Numbers)
		 				IANA (Internet Assigned Numbers Authority) 

						if any one group can be said to be in charge of the Internet, this is probably it.  It’s the only group with any sort of actual enforcement capability. 

						ICANN controls the allocation of Internet addresses and domain names

				ISOC (Internet Society)
						an open-membership organization that represents Internet users.

						it’s best known as the umbrella organization for the technical development of the Internet.

						it is the parent organization of the IETF (Internet Engineering Task) Force (ietf.org), which oversees most technical work. IT HAS offices in Washington, D.C. and Geneva.

				IGF (Internet Governance Forum)
						The IGF was created by the United Nations for international and policy-oriented discussions related to the Internet.

		ICANN has the toughest job.

	Network standards and documentation
		Accessing the Internet’s technical documentation is a crucial skill for system administrators.

		The technical documents are known as Requests for Comments or RFCs. Protocol standards, proposed changes, and informational bulletins usually end up as RFCs. Updates are new RFCs with their own reference numbers.


Networking road map pg499
	TCP/IP is a protocol “suite,” a set of network protocols designed to work smoothly together. It includes several components, each defined by a standards track RFC or series of RFCs:
			IP, the Internet Protocol, which routes data packets from one machine to another (RFC791)

			ICMP, the Internet Control Message Protocol, which provides support for IP, including error messages, routing assistance, and debugging help (RFC792)

			ARP, the Address Resolution Protocol, which translates IP addresses to hardware addresses (RFC826).
					This is actually a little white lie. ARP is not really part of TCP/IP. 

					It can be used with other protocol suites. However, it’s an integral part of the way TCP/IP works on most LAN media.

			UDP, the User Datagram Protocol, which provides unverified, one-way data delivery (RFC768)

			TCP, the Transmission Control Protocol, which implements reliable, full duplex, flow-controlled, error-corrected conversations (RFC793)

			These protocols are arranged in a hierarchy or “stack”, with the higher-level protocols making use of the protocols beneath them.

			TCP/IP is conventionally described as a five-layer system (as shown below):
					Application: 	arp; 
							SSH,FTP,HTTP; 
							DNS,Halo3; 
							traceroute
					Transport: 	TCP; 
							UDP
					Network: 	IP; 
							ICMP
					Link: 		ARP; 
							device drivers
					Physical: 	Copper, 
							optical fiber, 
							radio waves
					7.  Application layer
					6.  Presentation layer
					5.  Session layer
					4.  Transport layer
					3.  Network layer
					2.  Data link layer
					1.  Physical layer

			The actual TCP/IP protocols inhabit only three of these layers: transport, network and physical.

	IPv4 and IPv6 pg500
		The version of TCP/IP in use is revision 4. It uses four-byte IP addresses. IPv6 uses 16 bytes and incorporates several other lessons learned from the use of IPv4.

		IPv6 also integrates security and authentication into the basic protocol. The development of IPv6 was motivated by the fact that we are runnin gout of 4-byte IPV4 address space.

		If you understand IPv4, you already know most of what you need to know about IPv6, the main difference between lies in their addressing schemes. IPv6 introduces additional addressing concepts and some new notation. But that’s about it. 

	Packets and encapsulation pg501
		TCP/IP supports a variety of physical networks and transport systems, including: 
				wireless Ethernet 		Ethernet		
				token ring 			MPLS (Multiprotocol Label Switching)
				serial-line-based systems

		Hardware is managed within the link layer of the TCP/IP architecture. Higher-level protocols do not know or care about the specific hardware being used.

		Data travels on a network in the form of packets, bursts of data with a maximum length imposed by the link layer.
				Each packet consists of a header and a payload. The header tells where the packet came from and where it’s going. It can also include checksums, protocol-specific information, or other handling instructions.

				The payload is the data to be transferred.

				The layer of the protocol determins the data unit:
						TCP Layer:  		Segment
						IP Layer:  		Packet
						Link Layer:  		Frame

		As a packet travels down the protocol stack (from TCP or UDP transport to IP to Ethernet to the physical wire) each protocol adds its own header information.

		Encapsulation is when each protocol’s finished packet becomes the payload part of the packet generated by the next protocol

		On the receiving machine, the encapsulation is reversed as the packet travels back up the protocol stack.

		UDP packet being transmitted over Ethernet contains three different wrappers or envelopes:
				Ethernet Header 
					The source and next-hop desitination hardware address

					The length of the frame

					The frames checksum (CRC)

					The payload is the IP packet

				IP packet payload is the UDP segment

				UDP segement's payload is the data being transmitted

		|                 |             |            |                  |              |
		| Ethernet header | IPv4 header | UDP header | Application data | Ethernet CRC |
		|    14 Bytes     |  20  Bytes  |   8 Bytes  |    100 Bytes     |    4 Bytes   |
		|                 |             |            |                  |              |
		                                 >>>>>UDP segment (108 bytes)<<<
			           >>>>>>>>>>>IPv4 packet (128 bytes)<<<<<<<<<<<
		>>>>>>>>>>>>>>>>>>>>>>>>>Ethernet frame (146 bytes)<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
		
	Ethernet framing pg502
		The link layer adds headers to packets and to put separators between them. The headers contain each packet’s link-layer addressing information and checksums.

		The separators ensure that receivers can tell where one packet stops and the next one begins. The process of adding these extra bits is known generically as framing.

		The link layer is actually divided into two parts:
				Media Access Control (MAC) sublayer - The MAC layer deals with the media and transmits packets onto the wire.

				Link Layer Control (LLC) sublayer - The LLC layer handles the framing.

		A single standard for Ethernet framing is in common use: DIX Ethernet II.

	Maximum transfer unit - Link Layer
		The size of packets on a network may be limited both by hardware and by protocol. A standard Ethernet frame is traditionally 1,500 bytes.

		The size limit is associated with the link-layer protocol and is called the maximum transfer unit or MTU.
			ZEthernet 	- 1,500 bytes
			FDDI  		- 4,470 bytes
			Token 		- Configurable
			PPP modem 	- Configurable, 512 or 576
			PPP (T1,T3)	- 1,500 or 4,500 bytes

		The IP layer splits packets to conform to the MTU of a particular network link. If a packet is routed through several networks, an IPv4 router subdivides the packet in a process called fragmentation.

		Fragmentation of in-flight packets is an unwelcome chore for a busy router so IPv6 largely removes this feature. Packets can still be fragmented, but the **originating host** must do the work itself.

		Senders can discover the lowest-MTU link through which a packet must pass by setting the packet’s “do not fragment” flag.
				If a router cannot forward the packet without fragmenting it returns an ICMP error message to the sender.

				The ICMP packet includes the MTU and this MTU then becomes the governing packet size for communication with that destination.

		The TCP protocol does path MTU discovery automatically, even in IPv4. UDP is not so nice and is happy to shunt extra work to the IP layer.

		ZFragmentation problems can be insidious. Although path MTU discovery should automatically resolve MTU conflicts, an administrator must occasionally intervene.
				If you are using a tunneled architecture for a virtual private network, the tunneling header is added, they become 1,540 bytes or so and must be fragmented.

				Consult the 'ifconfig' man page to see how to set an interface’s MTU.

14.3 PACKET ADDRESSING pg503
	Network packets must be properly addressed in order to reach their destinations several addressing schemes are used in combination:
			MAC (media access control) addresses for use by hardware

			IPv4 and IPv6 network addresses for use by software

			Hostnames for use by people

	Hardware (MAC) media access control addressing
		Each of a host’s network interfaces usually has one link-layer MAC address that distinguishes it from other machines on the physical network, plus one or more IP addresses that identify the interface on the global Internet.

		This last part bears repeating: IP addresses identify **network interfaces, not machines**

		The lowest level of addressing is dictated by network hardware. 
				Ethernet devices are assigned a unique 6-byte hardware address at the time of manufacture.
						These addresses are traditionally written as a series of 2-digit hex bytes separated by colons; for example, 00:50:8D:9A:3B:DF.

				Token ring interfaces have a similar address that is also six bytes long. 

				Some point-to-point networks (such as PPP) need no hardware addresses at all; the identity of the destination is specified as the link is established.

				Ethernet address is divided into two parts.
						The first three bytes identify the manufacturer of the hardware,

						The last three bytes are a unique serial number that the manufacturer assigns.

						The 3-byte codes are actually IEEE Organizationally Unique Identifiers (OUIs), so you can also look up them up directly in the IEEE’s database at standards.ieee.org/regauth/oui

						In theory, Ethernet hardware addresses are permanently assigned and immutable. However, many network interfaces now let you override the hardware address and set one of your own choosing.

								This feature can be handy if all your switches filter it, or your DHCP server hands out addresses based on MAC addresses, or your MAC address is also a software license key.

								Spoofable MAC addresses are also helpful if you need to infiltrate a wireless network that uses MAC-based access control.

	IP addressing pg504
		At the next level up from the hardware, Internet addressing (more commonly known as IP addressing) is used. IP addresses are globally unique and hardware independent.
				In general, an IP address identifies a specific and unique destination.

				However, NAT (page 462) uses one interface’s IP address to handle traffic for multiple machines. 

				IP private address spaces (page 462) are addresses that multiple sites can use at once, as long as the addresses are not visible to the Internet

				Anycast addressing shares one IP address among several machines.

		The mapping from IP addresses to hardware addresses is implemented at the link layer of the TCP/IP model.
				On networks such as Ethernet that support broadcasting (that is, networks that allow packets to be addressed to “all hosts on this physical network”)
						Senders use the ARP protocol to discover mappings without assistance from a system administrator.

				In IPv6, an interface’s MAC address can be used as part of the IP address, making translation between IP and hardware addressing virtually automatic.
		
	Hostname "addressing"
		IP addresses are sequences of numbers, so they are hard for people to remember. Operating systems allow one or more hostnames to be associated with an IP address so that users can type rfc-editor.org instead of 128.9.160.27.

		Under UNIX and Linux, this mapping can be set up in several ways, ranging from a static file (/etc/hosts) to the LDAP database system to DNS, the world-wide Domain Name System.

		Hostnames are really IP address and refer to network interfaces rather than computers.

	Ports
		IP addresses identify a machine’s network interfaces, but they are not specific enough to address individual processes or services. Many may be actively using the same network at once.

		TCP and UDP extend IP addresses with a concept known as a port, a 16-bit number that supplements an IP address to specify a particular communication channel.

		Standard services such as email, FTP, and HTTP associate themselves with “well known” ports defined in /etc/services.
				You can find a full list of assigned ports at iana.org/assignments/port-numbers.

		To help prevent impersonation of these services, UNIX systems restrict server programs from binding to port numbers under 1,024 unless they are run as root.
				Anyone can communicate with a server running on a low port number; the restriction applies only to the program listening on the port.

	Address types
		The IP layer defines several broad types of address, some of which have direct counterparts at the link layer
				- Unicast – addresses that refer to a single network interface
				- Multicast – addresses that simultaneously target a group of hosts
				- Broadcast – addresses that include all hosts on the local subnet
				- Anycast – addresses that resolve to any one of a group of hosts
		
		Multicast addressing (target a group of hosts) facilitates applications such as video conferencing in which the same set of packets must be sent to all participants.
				The Internet Group Management Protocol (IGMP) constructs and manages sets of hosts that are treated as one multicast destination.

				Multicast is largely unused on today’s Internet, but it’s slightly more mainstream in IPv6. IPv6 broadcast addresses are really just specialized forms of multicast addressing.

		Anycast addresses (resolve to any one of a group of hosts) bring load balancing to the network layer by allowing packets to be delivered to whichever of several destinations is closest in terms of network routing.
				You might expect that they’d be implemented similarly to multicast addresses, but in fact they are more like unicast addresses.

				Anycast support are handled at the level of routing rather than IP. 

				Anycast addressing is formally described for IPv6, but the same tricks can be applied to IPv4, too—for example, as is done for root DNS name servers.

14.4 IP ADDRESSES: THE GORY DETAILS pg506
	With the exception of multicast addresses, Internet addresses consist of a network portion and a host portion.
			The network portion identifies a logical network.

			The host portion identifies a node on that network.

			In IPv4, addresses are four bytes long. The boundary between network and host portions is set administratively. 

			In IPv6, addresses are 16 bytes long and the network portion and host portion are always eight bytes each.

	IPv4 addresses are written as decimal numbers, one for each byte; for example, 209.85.171.147. The leftmost byte is the most significant and is always part of the network portion.
			When 127 is the first byte of an address, it denotes the “loopback network,” a fictitious network that has no real hardware interface and only one host.

			ZThe loopback address 127.0.0.1 always refers to the current host.

	Historically, IP addresses had an inherent “class” that depended on the first bits of the leftmost byte.
			The class determined which bytes of the address were in the network portion and which were in the host portion.

			Today, an explicit mask identifies the network portion, and the boundary can fall between two adjacent bits, not just between bytes.

	Classes A, B, and C denote regular IP addresses. Classes D and E are used for multicasting and research addresses.

	Below is the 
		class, 	1st byte, 	format, 	comments
		_____ 	_________ 	________ 	_______________________________________
		A 	1-127		N.H.H.H 	Very early networks, or reserved for DoD
		B 	128-191 	N.N.H.H 	Large sites, usually subnetted, were hard to get
		C 	192-223 	N.N.N.H 	Easy to get, ofen obtained in sets
		D 	224-239 	- 		Multicast addresses, not permanently assigned
		E 	240-255 	-  		Experimental addresses

	It’s rare for a single physical network to have more than 100 computers attached to it, so class A and class B addresses (which allow for 16,777,214 hosts and 65,534 hosts per network, respectively) are really quite silly and wasteful.
	
	Subnetting
		To make better use of these addresses, you can now reassign part of the host portion to the network portion.

		This is done by an explicit 4-byte “subnet mask” or “netmask”. In this case the 1's correspond to the network. And the 0's correspond to the host.
				The 1s must be leftmost and contiguous.

				At least eight bits must be allocated to the network part and at least two bits to the host. Ergo, there are really only 22 possible values for an IPv4 netmask.

		For example, the four bytes of a class B address would normally be interpreted as N.N.H.H.
				The implicit netmask for class B is therefore 255.255.0.0 in decimal notation.

				With a netmask of 255.255.255.0, however, the address would be interpreted as N.N.N.H.

				Use of the mask turns a single class B network address into 256 distinct class-C-like networks, each of which can support 254 hosts.

		Netmasks are assigned with the ifconfig command as each network interface is set up. By default, ifconfig uses the inherent class of an address to figure out which bits are in the network part. When you set an explicit mask, you simply override this behavior. (see Basic network configuration)

		Netmasks that do not end at a byte boundary can be annoying to decode and are often written as /XX, where XX is the number of bits in the network portion of the address.  This is sometimes called CIDR (see CIDR: Classless Inter-Domain Routing).
				For example, the network address 128.138.243.0/26 refers to the first of four networks whose first bytes are 128.138.243. The other three networks have 64, 128, and 192 as their fourth bytes.

				The netmask associated with these networks is 255.255.255.192 or 0xFFFFFFC0; in binary, it’s 26 ones followed by 6 zeros. 
					128 		138 		243 		 0
			IP Address 	128 		138 		243 		 0
			Dec mask 	255 		255 		255 		192
			Hex mask 	F F 		F F 		F F 		C 0
			Bin mask 	
						
				A /26 network has 6 bits left (32 – 26 = 6) to number hosts. 2^6 is 64, so the network has 64 potential host addresses. 

				However, it can only accommodate 62 actual hosts because the all-0 and all-1 host addresses are reserved (they are the network and broadcast addresses, respectively).

				In our 128.138.243.0/26 example, the extra two bits of network address obtained by subnetting can take on the values 00, 01, 10, and 11.
				1111 1111  - 1111 1111  - 1111 1111  - 1100 0000
				Note: there are 26 1'a and 6 0's. So, the first two bits of the last octect can be toggled as follows:
				The 128.138.243.0/24 network has thus been divided into four /26 networks:
					128.138.243.0/26 	(0 in decimal is **00**000000 in binary)
					128.138.243.64/26 	(64 in decimal is **01**000000 in binary)
					128.138.243.128/26 	(128 in decimal is **10**000000 in binary) 
					128.138.243.192/26 	(192 in decimal is **11**000000 in binary)

				The astericked bits of the last byte of each address are the bits that belong to the network portion of that byte.
			7 	6 	5 	4 	3 	2 	1 	0 

			0 	0 	0 	0 	0 	0 	0 	0 	== 2^0 * 0 =   0
			0 	1  	 	 	 	 	 	 	== 2^6 * 1 =  64
			1 	0 	 	 	 	 	 	 	== 2^7 * 1 = 128
			1 	1 	 	 	 	 	 	 	== 2^7 * 1 + 2^6 * 1 = 192


	Tricks and tools for subnet arithmetic
		The number of hosts per network and the value of the last byte in the netmask always add up to 256:
				last netmask byte = 256 – net size

		For example, 256 – 64 = 192, which is the final byte of the netmask in the preceding example.

		Another arithmetic fact is that the last byte of an actual network address (as opposed to a netmask) must be evenly divisible by the number of hosts per network.
				We see this fact in action in the 128.138.243.0/26 example, where the last bytes of the networks are 0, 64, 128, and 192—all divisible by 64.

		Given an IP address (say, 128.138.243.100), we cannot tell without the associated netmask what the network address and broadcast address will be.
				Below are the possibilities for /16 (the default for a class B address), /24 (a plausible value), and /26 (a reasonable value for a small network).

				/16 = FF.FF.0.0
				/24 = FF.FF.FF.0 {24 bits of 1's, 8 bits of 0's} {also 3 bytes of 1's and 1 byte of 0's}
				/26 = FF.FF.FF.C0

				F = 1111 {this is for a nibble (4bits)}
				C = 1100 {this is for a hex digit, or nibble or half-byte}
				{A=10=>1010, B=11=>1011, C=12=>1100, D=13=>1101, E=14=1110}
				FF = 255 {this is for a byte}
				FC = 252 {this is for a byte} 

			IP address         	Netmask  		Network        	Broadcast
			128.138.243.100/16 	255.255.0.0 		128.138.0.0   	128.138.255.255
			128.138.243.100/24 	255.255.255.0 		128.138.243.0 	128.138.243.255
			128.138.243.100/26 	255.255.255.192 	128.138.243.64 	128.138.243.127

			
		The network address and broadcast address steal two hosts from each network, so it would seem that the smallest meaningful network would have four possible hosts: two real hosts—usually at either end of a point-to-point link—and the network and broadcast addresses.
				To have four values for hosts requires two bits in the host portion. That is, 2^1 (or having one bit) would give you 2 values 0 & 1. While 2^2 (that is, having two bits) would yield 4 values 3, 2, 1, and 0.

				So such a network would be a /30 network that is 30 1's with two 0's. The first two bits of the last nibble are for the host. 

				The associated netmask 255.255.255.252 or 0xFFFFFFFC. We know that FF == 255, FC would subtract 3 from 255. C = 1100 so, subtract (2^1 * 1  +  2^0 * 1; or, 2 + 1 => 3).

				However, a /31 network is in fact treated as a special case (see RFC3021) and has no network or broadcast address. Both of its two addresses are used for hosts, and its netmask is 255.255.255.254.

				ZIP Calculator displays everything you might need to know about a network address and its netmask, broadcast address, hosts, etc.
						brew install ipcalc

				If a dedicated IP calculator isn’t available, the standard utility 'bc' makes a good backup utility since it can do arithmetic in any base. Set the input and output bases with the 'ibase' and 'obase' directives. Set the obase first; otherwise, it’s interpreted relative to the new 'ibase'

	CIDR: Classless Inter-Domain Routing
		CIDR relies on an explicit netmask to define the boundary between the network and host parts of an address. But unlike subnetting, CIDR allows the network portion to be made smaller than would be implied by an address’s implicit class.

		A short CIDR mask may have the effect of aggregating several networks for purposes of routing. Hence, CIDR is sometimes referred to as supernetting.

		CIDR simplifies routing information and imposes hierarchy on the routing process. For example, suppose that a site has been given a block of eight class C addresses numbered 192.144.0.0 through 192.144.7.0 (in CIDR notation, 192.144.0.0/21). 
				21 1's and 11 0's. 16 1's in the first two octects. So, the third octect is specified as: 
						1111 1000 -- note the last 3 bits are reserved for the network 0 - 7.
							$ ipcalc 192.144.0.0/21
							Address:   192.144.0.0          11000000.10010000.00000 000.00000000
							Netmask:   255.255.248.0 = 21   11111111.11111111.11111 000.00000000
							Wildcard:  0.0.7.255            00000000.00000000.00000 111.11111111
							=>
							Network:   192.144.0.0/21       11000000.10010000.00000 000.00000000
							HostMin:   192.144.0.1          11000000.10010000.00000 000.00000001
							HostMax:   192.144.7.254        11000000.10010000.00000 111.11111110
							Broadcast: 192.144.7.255        11000000.10010000.00000 111.11111111
							Hosts/Net: 2046                  Class C

				Internally, the site could use them as:
						1 network of length /21 with 2,046 hosts. This is calculated by the left over hosts: 09.FE (00000 111.11111110). The netmask is 255.255.248.0 (11111111.11111111.11111 000.00000000)
							$ echo '1024+512+256+128+64+32+16+8+4+2' | bc
							2046

						8 networks of length /24 with 254 hosts each, netmask 255.255.255.0
						$ echo '128+64+32+16+8+4+2' | bc # bits 7 - 1 used for hosts
						254

							000.1111111x - first network with 254 hosts
							001.1111111x - second network with 254 hosts
							010.1111111x - third network with 254 hosts

						16 networks of length /25 with 126 hosts each, netmask 255.255.255.128
							000.0111111x - first network with 126 hosts
							000.1111111x - second network with 126 hosts
							001.0111111x - third network with 126 hosts

						32 networks of length /26 with 62 hosts each, netmask 255.255.255.192
							000.0011111x - first network with 62 hosts
							000.0111111x - second network with 62 hosts
							001.1011111x - third network with 62 hosts

				But from the perspective of the Internet, it’s not necessary to have 32, 16, or even 8 routing table entries for these addresses. They all refer to the same organization, and all the packets go to the same ISP. 

				A single routing entry for 192.144.0.0/21 suffices. CIDR makes it easy to allocate portions of class A and B addresses and thus increases the number of available addresses manyfold.

				Inside your network, you can mix and match regions of different subnet lengths as long as all the pieces fit together without overlaps. 

				This is called variable length subnetting.

				For example, an ISP with the 192.144.0.0/21 allocation could define some /30 networks for point-to-point customers, some /24s for large customers, and some /27s for smaller folks.

				All the hosts on a network must be configured with the same netmask. You can’t tell one host that it is a /24 and another host on the same network that it is a /25.

	Address allocation
		Only network numbers are formally assigned; sites must define their own host numbers to form complete IP addresses. You can subdivide the address space that has been assigned to you into subnets in whatever manner you like.

		ICANN (the Internet Corporation for Assigned Names and Numbers) has delegated blocks of addresses to five regional Internet registries, and these regional authorities are responsible for doling out subblocks to ISPs within their regions.

	Private addresses and network address translation (NAT)
		Another factor that has helped decelerate the rate at which IPv4 addresses are consumed is the use of private IP address spaces (RFC1918).

		These addresses are used by your site internally but are never shown to the Internet. A border router translates between your private address space and the address space assigned by your ISP. 

		RFC1918 sets aside 1 class A network, 16 class B networks, and 256 class C networks that will never be globally allocated and can be used internally by any site. The “CIDR range” column shows each range in the more compact CIDR notation; it does not add additional information.
				IP Class     	From          	To                	CIDR Range
				Class A 		10.0.0.0 		10.255.255.255 		10.0.0.0/8
				------------------------------------------------------------------
				$ ipcalc 10.0.0.0/8
				Address:   10.0.0.0             00001010. 00000000.00000000.00000000
				Netmask:   255.0.0.0 = 8        11111111. 00000000.00000000.00000000
				Wildcard:  0.255.255.255        00000000. 11111111.11111111.11111111
				=>
				Network:   10.0.0.0/8           00001010. 00000000.00000000.00000000
				HostMin:   10.0.0.1             00001010. 00000000.00000000.00000001
				HostMax:   10.255.255.254       00001010. 11111111.11111111.11111110
				Broadcast: 10.255.255.255       00001010. 11111111.11111111.11111111
				Hosts/Net: 16777214              Class A, Private Internet


				Class B 		172.16.0.0 		172.31.255.255 		172.16.0.0/12 
				------------------------------------------------------------------
				$ ipcalc 172.16.0.0/12
				Address:   172.16.0.0           10101100.0001 0000.00000000.00000000
				Netmask:   255.240.0.0 = 12     11111111.1111 0000.00000000.00000000
				Wildcard:  0.15.255.255         00000000.0000 1111.11111111.11111111
				=>
				Network:   172.16.0.0/12        10101100.0001 0000.00000000.00000000
				HostMin:   172.16.0.1           10101100.0001 0000.00000000.00000001
				HostMax:   172.31.255.254       10101100.0001 1111.11111111.11111110
				Broadcast: 172.31.255.255       10101100.0001 1111.11111111.11111111
				Hosts/Net: 1048574               Class B, Private Internet


				Class C 		192.168.0.0 	192.168.255.255 	192.168.0.0/16
				------------------------------------------------------------------
				$ ipcalc 192.168.0.0/16
				Address:   192.168.0.0          11000000.10101000. 00000000.00000000
				Netmask:   255.255.0.0 = 16     11111111.11111111. 00000000.00000000
				Wildcard:  0.0.255.255          00000000.00000000. 11111111.11111111
				=>
				Network:   192.168.0.0/16       11000000.10101000. 00000000.00000000
				HostMin:   192.168.0.1          11000000.10101000. 00000000.00000001
				HostMax:   192.168.255.254      11000000.10101000. 11111111.11111110
				Broadcast: 192.168.255.255      11000000.10101000. 11111111.11111111
				Hosts/Net: 65534                 Class C, Private Internet

		The original idea was that sites would choose an address class from among these options to fit the size of their organizations. 

		But now that CIDR and subnetting are universal, it probably makes the most sense to use the class A address (subnetted, of course) for all new private networks. pg511

		To allow hosts that use these private addresses to talk to the Internet, the site’s border router runs a system called NAT (Network Address Translation).

		pg 511
		NAT intercepts packets addressed with these internal addresses and rewrites their source addresses, using a real external IP address and perhaps a different source port number.

		It also maintains a table of the mappings it has made between internal and external address/port pairs so that the translation can be performed in reverse when answering packets arrive from the Internet.

		NAT’s use of port number mapping multiplexes several conversations onto the same IP address so that a single external address can be shared by many internal hosts. In some cases, a site can get by with only one “real” IP address.
				For example, this is the default configuration for most mass-market routers used with cable and DSL modems.

				A site that uses NAT must still request a small section of address space from its ISP, but most of the addresses thus obtained are used for NAT mappings and are not assigned to individual hosts.

				If the site later wants to choose another ISP, only the border router and its NAT configuration need be updated, not the configurations of the individual hosts.

				Large organizations must institute some form of central coordination so that all hosts have unique IP addresses. The situation can become complicated when one company merges with another. The combined organization must often renumber

				It is possible to have a UNIX or Linux box perform the NAT function, but most sites prefer to delegate this task to their routers or network connection devices.
						Of course, many routers now run embedded Linux kernels. Even so, these dedicated systems are still generally more proficient and more secure than general-purpose computers that also forward packets.

				An incorrect NAT configuration can let private-address-space packets escape onto the Internet. The packets may get to their destinations, but answering packets won’t be able to get back.

				CAIDA, an organization that collects operational data finds that 0.1% to 0.2% of packets have either private addresses or bad checksums. CAIDA, pronounced “kay duh,” is the Cooperative Association for Internet Data Analysis at the San Diego Supercomputer Center on the UCSD campus (caida.org).

		One issue raised by NAT is that an arbitrary host on the Internet cannot initiate connections to your site’s internal machines.
				To get around this limitation, NAT implementations let you preconfigure externally visible “tunnels” that connect to specific internal hosts and ports.

				Many routers also support the Universal Plug and Play (UPnP) standards promoted by Microsoft. This allows interior hosts to set up their own dynamic NAT tunnels. 
						This can be either a godsend or a security risk, depending on your perspective. The feature is easily disabled at the router if you wish to do so.

		Another issue is that some applications embed IP addresses in the data portion of packets; these applications are foiled or confused by NAT.
				Examples include some media streaming systems, routing protocols, and FTP commands. NAT sometimes breaks VPNs (virtual private networks), too. 

	IPv6 addressing
		IPv6 addresses are 128 bits long. These long addresses were originally intended to solve the problem of IP address exhaustion. But now that they’re here, they are being exploited to help with issues of routing, mobility, and locality of reference. 

		IPv4 addresses were not designed to be geographically clustered in the manner of phone numbers or zip codes, but clustering was added after the fact in the form of the CIDR conventions.
				Of course, “geography” is really routing space rather than physical location. The hierarchical subassignment of network addresses is assumed throughout IPv6.

				Your IPv6 ISP assigns you an address prefix that you prepend to the local parts of your addresses, at your border router.

		The boundary between the network portion and the host portion of an IPv6 address is fixed at /64. Therefore, true subnetting no longer exists in the IPv6 world, although the term “subnet” lives on as a synonym for “local network."

		Even though network numbers are always 64 bits long, routers needn’t pay attention to all 64 bits when making routing decisions. They can route packets based on prefixes, just as they do under CIDR.
				ISPs are free to set delegation boundaries wherever they wish.

		The 64-bit host ID can potentially be derived from the hardware interface’s 48-bit MAC address.
				The host ID is the MAC address with the two bytes 0xFFFE inserted in the middle and one bit (bit 6 of the first byte, numbering bits from the left, starting at 0) complemented; see RFC4291.

				The standard for converting 48-bit MAC addresses into 64-bit IP host numbers is known as EUI-64.

				This scheme allows for automatic host numbering, which is a nice feature for sysadmins since only the subnet needs to be managed.

		The fact that the MAC address can be seen at the IP layer has both good and bad implications. 
				The good part is that host number configuration can be completely automatic.

				The bad part is that the brand and model of interface card are encoded in the first half of the MAC address, so prying eyes and hackers with code for a particular architecture will be helped along.

				The IPv6 standards point out that sites are not required to use MAC addresses to derive host IDs; they can use whatever numbering system they want.

14.5 ROUTING
	Routing is the process of directing a packet through the maze of networks that stand between its source and its destination.
			In the TCP/IP system, it is similar to asking for directions in an unfamiliar country. 

			The first person you talk to might point you toward the right city. Once you were a bit closer to your destination, the next person might be able to tell you how to get to the right street. Eventually, you get close enough that someone can identify the building you’re looking for.

	Routing information takes the form of rules (“routes”), such as “To reach network A, send packets through machine C.”
			There can also be a default route that tells what to do with packets bound for a network to which there is no explicit route.

	Routing information is stored in a table in the kernel. Each table entry has several parameters, including a mask for each listed network.
			To route a packet to a particular address, the kernel picks the most specific of the matching routes—that is, the one with the longest mask.

			If the kernel finds no relevant route and no default route, then it returns a “network unreachable” ICMP error to the sender.

	The word “routing” is commonly used to mean two distinct things:
			• Looking up a network address in the routing table to forward a packet toward its destination
			• Building the routing table in the first place

	In this section we examine the forwarding function and look at how routes can be manually added to or deleted from the routing table. 

	We defer the more complicated topic of routing protocols that build and maintain the routing table until Chapter 15.

	Routing tables
		You can examine a machine’s routing table with netstat -r.
				$ netstat -r
				Routing tables

				Internet:
				Destination        Gateway            Flags        Refs      Use   Netif Expire
				default            172.16.0.1         UGSc          279        0     en0
				127                localhost          UCS             0        0     lo0
				localhost          localhost          UH              1     1306     lo0
				169.254            link#5             UCS             1        0     en0
				169.254.209.137    28:e0:2c:5b:ff:29  UHLSW           0        0     en0   1071
				172.16             link#5             UCS            40        0     en0
				172.16.0.1/32      link#5             UCS             1        0     en0
				172.16.0.1         fc:5b:39:19:8c:e1  UHLWIir       226       16     en0   1020

		Use netstat -rn to avoid DNS lookups and present all the information numerically, which is generally more useful.

		We discuss netstat in more detail starting on page 917 (868), but here is a short example to give you a better idea of what routes look like:
				redhat$ netstat -rn
				Kernel IP routing table
				
				Destination 	Genmask 		Gateway 		Fl 	MSS 	Iface
				
			***	132.236.227.0	255.255.255.0 	132.236.227.93 	U 	1500 	eth0***
				default 		0.0.0.0 		132.236.227.1 	UG 	1500 	eth0
			***	132.236.212.0 	255.255.255.192	132.236.212.1 	U 	1500 	eth1***
				132.236.220.64	255.255.255.192	132.236.212.6	UG 	1500 	eth1
				127.0.0.1 		255.255.255.255	127.0.0.1 		U 	3584 	lo

		This host has two network interfaces: 
				132.236.227.93 (eth0) on the network 132.236.227.0/24 and 
				132.236.212.1 (eth1) on the network 132.236.212.0/26.

		The destination field is usually a network address, although you can also add host-specific routes (their genmask is 255.255.255.255 since all bits are consulted).

		An entry’s gateway field must contain the full IP address of a local network interface or adjacent host; on Linux kernels it can be 0.0.0.0 to invoke the default gateway.
				For example, the fourth route in the table above says that to reach the network 132.236.220.64/26, packets must be sent to the gateway 132.236.212.6 through interface eth1.

				The second entry is a default route; 
					packets not explicitly addressed to any of the three networks listed (or to the machine itself) are sent to the default gateway host, 132.236.227.1.

		A host can only route packets to gateway machines that are reachable through a directly connected network. 
				The local host’s job is limited to moving packets one hop closer to their destinations, so it is pointless to include information about nonadjacent gateways in the local routing table.

				Each gateway that a packet visits makes a fresh next-hop routing decision based on its own local routing database.

				The IP source routing feature is an exception to this rule; see page 522 (473).

		Routing tables can be configured statically, dynamically, or with a combination of the two approaches. 
				A static route is one that you enter explicitly with the route command.
						# route add -net 132.236.220.64 netmask 255.255.255.192
						   gw 132.236.212.6 eth1
						# route add default gw 132.236.227.1 eth0
				Static routes remain in the routing table as long as the system is up; they are often set up at boot time from one of the system startup scripts.

				Linux commands add the fourth and second routes displayed by 'netstat -rn' above. 

				The first and third routes in that display were added by 'ifconfig' when the eth0 and eth1 interfaces were configured.

		The final route is also added at boot time. It configures the loopback interface, which prevents packets sent from the host to itself from going out on the network.
				Instead, they are transferred directly from the network output queue to the network input queue inside the kernel. 

		In a stable local network, static routing is an efficient solution. However, it requires that the system administrator know the topology of the network accurately at boot time and that the topology not change often.
				Most machines on a local area network have only one way to get out to the rest of the network, so the routing problem is easy.

				A default route added at boot time suffices to point toward the way out. Hosts that use DHCP (see page 518 (469) to get their IP addresses can also obtain a default route with DHCP.

		For more complicated network topologies, dynamic routing is required. Dynamic routing is implemented by a daemon process that maintains and modifies the routing table.
				Routing daemons on different hosts communicate to discover the topology of the network and to figure out how to reach distant destinations.

				Sev-eral routing daemons are available. See Chapter 15, Routing, for details.

ICMP redirects
	Although IP generally does not concern itself with the management of routing information, it does define a naive damage control feature called an ICMP redirect.

	When a router forwards a packet to a machine on the same network from which the packet was originally received, something is clearly wrong.
			Since the sender, the router, and the next-hop router are all on the same network, the packet could have been forwarded in one hop rather than two.

			The router can conclude that the sender’s routing tables are inaccurate or incomplete.
					In this situation, the router can notify the sender of its problem by sending an ICMP redirect packet.

					In effect, a redirect says, “You should not be sending packets for host xxx to me; you should send them to host yyy instead.”

			In theory, the recipient of a redirect can adjust its routing table to fix the problem.

			In practice, redirects contain no authentication information and are therefore untrustworthy.
					Dedicated routers usually ignore redirects, but most UNIX and Linux systems accept them and act on them by default.

					You’ll need to consider the possible sources of redirects in your network and disable their acceptance if they could pose a problem.

			Under Linux, the variable 'accept_redirects' in the /proc hierarchy controls the acceptance of ICMP redirects. 
					See page 553 (504) for instructions on examining and resetting this variable.

			On Solaris, use ndd -set /dev/ip ip_ignore_redirect 1 to disregard ICMP redirects. See page 498 for more details.

			Although HP-UX also uses the ndd command to control its IP protocol stack, the underlying IP implementation lacks the ability to ignore ICMP redirects. 
					However, you can arrange to have the routes that result from these redirects deleted from the routing table a second later with

							ndd -set /dev/ip ip_ire_redirect_interval 1000

					Some versions of HP-UX have enforced minima of 5 or 60 seconds on this parameter (which is expressed in milliseconds), but HP-UX 11 appears to accept smaller values without complaint.

14.6 ARP: THE ADDRESS RESOLUTION PROTOCOL
	Although IP addresses are hardware-independent, hardware addresses must still be used to actually transport data across a network’s link layer.
			Except on point-to-point links, on which the identity of the destination is sometimes implicit.

	ARP, the Address Resolution Protocol, discovers the hardware address associated with a particular IP address.

	It can be used on any kind of network that supports broadcasting but is most commonly described in terms of Ethernet.

	If host A wants to send a packet to host B on the same Ethernet, it uses ARP to discover B’s hardware address.
			If B is not on the same network as A, host A uses the routing system to determine the next-hop router along the route to B. 

			Then uses ARP to find that router’s hardware address.

			Since ARP uses broadcast packets, which cannot cross networks.

			It can only be used to find the hardware addresses of machines directly connected to the sending host’s local network.
					Routers can in fact be configured to flood broadcast packets to other networks, but this is generally a bad idea. 

					If you find yourself wanting to forward broadcasts, there is most likely something amiss with your network or server architecture.

	Every machine maintains a table in memory called the ARP cache, which contains the results of recent ARP queries.

	Under normal circumstances, many of the addresses a host needs are discovered soon after booting, so ARP does not account for a lot of network traffic.

	ARP works by broadcasting a packet of the form “Does anyone know the hardware address for 128.138.116.4?”
			The machine being searched for recognizes its own IP address and replies, “Yes, that’s the IP address assigned to one of my network interfaces, and the corresponding Ethernet address is 8:0:20:0:fb:6a.”

			The original query includes the IP and Ethernet addresses of the requestor so that the machine being sought can reply without issuing an ARP query of its own.
					Thus, the two machines learn each other’s ARP mappings with only one exchange of packets. 

					Other machines that overhear the requestor’s initial broadcast can record its address mapping, too.

	The 'arp' command examines and manipulates the kernel’s ARP cache, adds or deletes entries, and flushes or shows the table. 

	'arp -a' displays the contents of the ARP cache; output formats vary.

	The arp command is generally useful only for debugging and for situations that involve special hardware. 
			For example, if two hosts on a network are using the same IP address, one has the right ARP table entry and one is wrong. 

			You can use the arp command to track down the offending machine.

14.7 DHCP: THE DYNAMIC HOST CONFIGURATION PROTOCOL
	When you plug a device or computer into a network 
			it usually obtains an IP address for itself on the local network, 

			sets up an appropriate default route, and 

			connects itself to a local DNS server

	The Dynamic Host Configuration Protocol (DHCP) is the hidden Svengali that makes this magic happen.

	The protocol lets a DHCP client “lease” a variety of network and administrative parameters from a central server that is authorized to distribute them.
			The leasing paradigm is particularly convenient for PCs that are turned off when not in use and for networks that must support transient guests such as laptops.

	Leasable parameters include:
			• IP addresses and netmasks
			• Gateways (default routes)
			• DNS name servers
			• Syslog hosts
			• WINS servers, X font servers, proxy servers, NTP servers
			• TFTP servers (for loading a boot image)

	Clients must report back to the DHCP server periodically to renew their leases.
			If a lease is not renewed, it eventually expires. The DHCP server is then free to assign the address (or whatever was being leased) to a different client. 

			The lease period is configurable, but it’s usually quite long (hours or days).

	Even if you want each host to have its own permanent IP address, DHCP can save you time and suffering.
			Once the server is up and running, clients can use it to obtain their network configuration at boot time. 

			No fuss, no mess, and most importantly, a minimum of local configuration on the client machines.

DHCP software
	ISC, the Internet Systems Consortium, maintains a very nice open source reference implementation of DHCP.

	Non-Linux systems often have their own home-grown DCHP implementations, and unfortunately all our example UNIX systems fall into this category.

	It’s best not to tamper with the client side of DHCP. In the next few sections, we briefly 
			discuss the DHCP protocol, 

			explain how to set up the ISC server that implements it, and 

			review some client configuration issues.

How DHCP works
	DHCP is a backward-compatible extension of BOOTP, a protocol originally devised to help diskless UNIX workstations boot.

	DHCP adds the concept of a lease period for assigned values.

	A DHCP client begins its interaction with a DHCP server by broadcasting a “Help! Who am I?” message. 
			Clients initiate conversations with the DHCP server by using the generic all-ones broadcast address. 

			The clients don’t yet know their subnet masks and therefore can’t use the subnet broadcast address.

	If a DHCP server is present on the local network, it negotiates with the client to provide an IP address and other networking parameters.
			If there is no DHCP server on the local net, servers on different subnets can receive the initial broadcast message through a separate piece of DHCP software that acts as a relay agent.

	When the client’s lease time is half over, it attempts to renew its lease. The server is obliged to keep track of the addresses it has handed out, and this information must persist across reboots.

ISC’s DHCP software
	ISC’s server daemon is called 'dhcpd', and its configuration file is 'dhcpd.conf', usually found in '/etc' or '/etc/dhcp3'.
			The format of the config file is a bit fragile; leave out a semicolon and you may receive a cryptic, unhelpful error message.

	When setting up a new DHCP server, you must also make sure that an empty lease database file has been created.
			Check the summary at the end of the man page for dhcpd to find the correct location for the lease file on your system. It’s usually somewhere underneath /var.

	To set up the dhcpd.conf file, you need the following information:
			• The subnets for which dhcpd should manage IP addresses, and the ranges of addresses to dole out
			• A list of static IP address assignments you want to make (if any), along with the MAC (hardware) addresses of the recipients
			• The initial and maximum lease durations, in seconds
			• Any other options the server should pass to DHCP clients: netmask, default route, DNS domain, name servers, etc.

	The 'dhcpd' man page outlines the configuration process, and the 'dhcpd.conf' man page covers the exact syntax of the config file.

	In addition to setting up your configuration, make sure dhcpd is started automatically at boot time. (See Chapter 3, Booting and Shutting Down, for instructions.)
			It’s helpful to make startup of the daemon conditional on the existence of the dhcpd.conf file if your system doesn’t do this for you automatically
			
519
		Z

		Z

				Z

				Z

				Z

				Z

						Z

						Z

	Z

	Z

	Z
		Z

		Z

		Z

		Z

		Z

		Z

		Z

		Z

		Z





